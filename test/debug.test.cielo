# debug.test.cielo

import {UnitTesterNorm, UnitTester} from '@jdeighan/unit-tester'
import {undef, OL, isString} from '@jdeighan/coffee-utils'
import {blockToArray, arrayToBlock} from '@jdeighan/coffee-utils/block'
import {log, LOG, setLogger, debugLog} from '@jdeighan/coffee-utils/log'
import {untabify} from '@jdeighan/coffee-utils/indent'
import {CallStack} from '@jdeighan/coffee-utils/stack'
import {
	setDebugging, debug, getFuncList, funcMatch, debugDebug,
	} from '@jdeighan/coffee-utils/debug'

simple = new UnitTesterNorm()
lLines = undef
setLogger (str) -> lLines.push(untabify(str))

# ---------------------------------------------------------------------------

(() ->

	lFuncList = getFuncList("get fetch obj.match func+ obj.list+")
	simple.equal {{LINE}}, lFuncList, [
		{
			name: 'get'
			plus: false
			}
		{
			name: 'fetch'
			plus: false
			}
		{
			object: 'obj'
			name: 'match'
			plus: false
			}
		{
			name: 'func'
			plus: true
			}
		{
			object: 'obj'
			name: 'list'
			plus: true
			}
		]

	)()

# ---------------------------------------------------------------------------
# funcMatch() expects a CallStack object as 1st parameter

(() ->
	stack = new CallStack()
	stack.enter('get')

	lFuncList = getFuncList("get")
	simple.equal {{LINE}}, funcMatch(stack, lFuncList), true
	)()

# ---------------------------------------------------------------------------

(() ->
	stack = new CallStack()
	stack.enter('get')

	lFuncList = getFuncList("get+")
	simple.equal {{LINE}}, funcMatch(stack, lFuncList), true
	)()

# ---------------------------------------------------------------------------

(() ->
	stack = new CallStack()
	stack.enter('StringInput.get')

	lFuncList = getFuncList("get")
	simple.equal {{LINE}}, funcMatch(stack, lFuncList), true
	)()

# ---------------------------------------------------------------------------

(() ->
	setDebugging true
	lLines = []
	debug 'abc'
	simple.equal {{LINE}}, lLines, ['abc']
	)()

# ---------------------------------------------------------------------------

(() ->
	setDebugging true
	lLines = []
	debug 'value', undef
	debugDebug false
	simple.equal {{LINE}}, lLines, ['value = undef']
	)()

# ---------------------------------------------------------------------------

class TraceTester extends UnitTester

	initialize: () ->
		lLines = []

	transformValue: (block) ->

		for line in blockToArray(block)
			debug line
		return arrayToBlock(lLines)

tester = new TraceTester()

# ---------------------------------------------------------------------------

(() ->
	setDebugging true
	lLines = []
	debug 'enter myfunc'
	debug 'something'
	debug 'more'
	debug 'return 42 from myfunc'
	debug "Answer is 42"
	simple.equal {{LINE}}, lLines, [
		"enter myfunc"
		"│   something"
		"│   more"
		"└─> return 42 from myfunc"
		"Answer is 42"
		]
	)()

# ---------------------------------------------------------------------------

(() ->
	setDebugging 'myfunc'
	lLines = []
	debug 'enter myfunc'
	debug 'something'
	debug 'more'
	debug 'return 42 from myfunc'
	debug "Answer is 42"
	simple.equal {{LINE}}, lLines, [
		"enter myfunc"
		"│   something"
		"│   more"
		"└─> return 42 from myfunc"
		]
	)()

# ---------------------------------------------------------------------------

(() ->
	setDebugging true
	lLines = []
	debug 'enter myfunc'
	debug 'something'
	debug 'enter newfunc'
	debug 'something else'
	debug 'return abc from newfunc'
	debug 'return 42 from myfunc'
	simple.equal {{LINE}}, lLines, [
		"enter myfunc"
		"│   something"
		"│   enter newfunc"
		"│   │   something else"
		"│   └─> return abc from newfunc"
		"└─> return 42 from myfunc"
		]
	)()

# ---------------------------------------------------------------------------

(() ->
	setDebugging "myfunc newfunc"
	lLines = []
	debug 'enter myfunc'
	debug 'something'
	debug 'enter newfunc'
	debug 'something else'
	debug 'return abc from newfunc'
	debug 'return 42 from myfunc'
	simple.equal {{LINE}}, lLines, [
		"enter myfunc"
		"│   something"
		"│   enter newfunc"
		"│   │   something else"
		"│   └─> return abc from newfunc"
		"└─> return 42 from myfunc"
		]
	)()

# ---------------------------------------------------------------------------

(() ->
	setDebugging "myfunc"

	lLines = []
	debug 'enter myfunc'
	debug 'something'
	debug 'enter newfunc'
	debug 'something else'
	debug 'return abc from newfunc'
	debug 'return 42 from myfunc'
	simple.equal {{LINE}}, lLines, [
		"enter myfunc"
		"│   something"
		"│   call newfunc"
		"└─> return 42 from myfunc"
		]
	debugDebug false
	)()

# ---------------------------------------------------------------------------

(() ->
	setDebugging "myfunc"
	lLines = []
	obj = {
		first: 1
		second: 2
		}
	debug 'enter myfunc'
	debug 'something'
	debug 'obj', obj
	debug 'return 42 from myfunc'
	simple.equal {{LINE}}, lLines, [
		"enter myfunc"
		"│   something"
		"│   obj:"
		"│       ---"
		"│       first: 1"
		"│       second: 2"
		"└─> return 42 from myfunc"
		]
	)()

# ---------------------------------------------------------------------------

(() ->
	setDebugging "myfunc"
	lLines = []
	obj = {
		first: "this is the first item in the hash"
		second: "this is the second item in the hash"
		}
	debug 'enter myfunc'
	debug 'something'
	debug 'obj', obj
	debug 'return 42 from myfunc'
	simple.equal {{LINE}}, lLines, [
		"enter myfunc"
		"│   something"
		"│   obj:"
		"│       ---"
		"│       first: this˳is˳the˳first˳item˳in˳the˳hash"
		"│       second: this˳is˳the˳second˳item˳in˳the˳hash"
		"└─> return 42 from myfunc"
		]
	)()

# ---------------------------------------------------------------------------
# --- Test ability to debug only a particular function

(() ->
	lLines = []
	setDebugging 'innerFunc'

	debug "enter myfunc"
	debug "something"
	debug "enter innerFunc"
	debug "something else"
	debug "return nothing from innerFunc"
	debug "this should not appear"
	debug "return 42 from myfunc"
	simple.equal {{LINE}}, lLines, [
		"enter innerFunc"
		"│   something else"
		"└─> return nothing from innerFunc"
		]
	setDebugging false
	)()

# ---------------------------------------------------------------------------
# --- Test ability to debug only a particular function
#     using actual functions!

(() ->
	lLines = []
	setDebugging 'innerFunc'

	innerFunc = () ->

		debug "enter innerFunc()"
		debug "answer is 42"
		x = 42
		debug "return from innerFunc()"
		return

	outerFunc = () ->

		debug "enter outerFunc()"
		innerFunc()
		debug "return from outerFunc()"
		return

	outerFunc()

	simple.equal {{LINE}}, lLines, [
		"enter innerFunc()"
		"│   answer is 42"
		"└─> return from innerFunc()"
		]
	setDebugging false
	)()

# ---------------------------------------------------------------------------

(() ->
	setDebugging true
	lLines = []

	line = 'first line'
	debug "line is #{OL(line)}"

	simple.equal {{LINE}}, lLines.length, 1
	simple.equal {{LINE}}, lLines, [
		"line is 'first˳line'"
		]
	setDebugging false
	)()

# ---------------------------------------------------------------------------

(() ->
	setDebugging true
	lLines = []

	obj = {
		first: "this is the first item in the hash"
		second: "this is the second item in the hash"
		}

	debug 'enter myfunc'
	debug 'return from myfunc', obj
	debug "Answer is 42"
	simple.equal {{LINE}}, lLines, [
		"enter myfunc"
		"└─> return from myfunc"
		"        ---"
		"        first: this˳is˳the˳first˳item˳in˳the˳hash"
		"        second: this˳is˳the˳second˳item˳in˳the˳hash"
		"Answer is 42"
		]
	)()

# ---------------------------------------------------------------------------

(() ->
	setDebugging true
	lLines = []

	longBlock = """
		this is one very long line
		this is another very long line
		"""

	debug 'enter myfunc'
	debug 'return from myfunc', longBlock
	debug "Answer is 42"
	simple.equal {{LINE}}, lLines, [
		"enter myfunc"
		"└─> return from myfunc"
		"        =========================================="
		"        this˳is˳one˳very˳long˳line"
		"        this˳is˳another˳very˳long˳line"
		"        =========================================="
		"Answer is 42"
		]
	)()

# ---------------------------------------------------------------------------

(() ->
	setDebugging 'get'

	block = """
		enter myfunc
		enter get
		enter fetch
		return from fetch
		return from get
		enter nofunc
		return from nofunc
		enter get
		something
		return from get
		return from myfunc
		"""

	tester.equal {{LINE}}, block, """
		enter get
		│   call fetch
		└─> return from get
		enter get
		│   something
		└─> return from get
		"""
	)()

# ---------------------------------------------------------------------------
#     Test debugging object methods

(() ->
	class StrInput

		mapArray: (lLines) ->
			result = ''
			for line in lLines
				result += @mapLine(line)
				result += "\n"
			return result

		mapLine: (line, level) ->

			debug "enter StrInput.mapLine()"
			assert line? && isString(line), "StrInput.mapLine(): not a string"
			line = "> #{line}"
			debug "return #{OL(line)} from StrInput.mapLine()"
			return line

	setDebugging true
	lLines = []
	input = new StrInput()
	result = input.mapArray(['abc','def'])

	simple.equal {{LINE}}, result, "> abc\n> def\n"
	simple.equal {{LINE}}, lLines, [
		'enter StrInput.mapLine()',
		"└─> return '>˳abc' from StrInput.mapLine()",
		'enter StrInput.mapLine()',
		"└─> return '>˳def' from StrInput.mapLine()"
		]
	)()

# ---------------------------------------------------------------------------
#     Test debugging particular functions

(() ->

	func = (x) ->

		debug "enter func()"
		debug "got #{x}"
		debug "return from func()"
		return

	coffeeCodeToJS = (code) ->

		debug "enter coffeeCodeToJS()"
		func(5)
		debug "return from coffeeCodeToJS()"
		return

	setDebugging 'coffeeCodeToJS'
	lLines = []

	coffeeCodeToJS("x = 42")

	simple.equal {{LINE}}, lLines, [
		'enter coffeeCodeToJS()'
		'│   call func()'
		'└─> return from coffeeCodeToJS()'
		]
	)()

# ---------------------------------------------------------------------------
