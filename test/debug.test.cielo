# debug.test.cielo

import {undef, OL, isString} from '@jdeighan/coffee-utils'
import {blockToArray, arrayToBlock} from '@jdeighan/coffee-utils/block'
import {log, setLogger} from '@jdeighan/coffee-utils/log'
import {
	setDebugging, debug, resetDebugging, funcMatch, useStdLogger,
	} from '@jdeighan/coffee-utils/debug'
import {UnitTester} from '@jdeighan/coffee-utils/test'

simple = new UnitTester()
useStdLogger()

# ---------------------------------------------------------------------------

lLines = undef
setLogger (str) -> lLines.push(str)

# ---------------------------------------------------------------------------

(() ->
	resetDebugging true
	lLines = []
	debug 'abc'
	simple.equal {{LINE}}, lLines, ['abc']
	)()

# ---------------------------------------------------------------------------

class TraceTester extends UnitTester

	initialize: () ->
		lLines = []

	normalize: (text) ->
		return text

	transformValue: (block) ->

		for line in blockToArray(block)
			debug line
		return arrayToBlock(lLines)

tester = new TraceTester()

# ---------------------------------------------------------------------------

(() ->
	lLines = []
	debug 'enter myfunc'
	debug 'something'
	debug 'more'
	debug 'return 42 from myfunc'
	debug "Answer is 42"
	simple.equal {{LINE}}, lLines, [
		"enter myfunc"
		"│   something"
		"│   more"
		"└─> return 42 from myfunc"
		"Answer is 42"
		]
	)()

# ---------------------------------------------------------------------------

(() ->
	lLines = []
	debug 'enter myfunc'
	debug 'something'
	debug 'enter newfunc'
	debug 'something else'
	debug 'return abc from newfunc'
	debug 'return 42 from myfunc'
	simple.equal {{LINE}}, lLines, [
		"enter myfunc"
		"│   something"
		"│   enter newfunc"
		"│   │   something else"
		"│   └─> return abc from newfunc"
		"└─> return 42 from myfunc"
		]
	)()

# ---------------------------------------------------------------------------

(() ->
	lLines = []
	obj = {
		first: 1
		second: 2
		}
	debug 'enter myfunc'
	debug 'something'
	debug 'obj', obj
	debug 'return 42 from myfunc'
	simple.equal {{LINE}}, lLines, [
		"enter myfunc"
		"│   something"
		'│   obj = {"first":1,"second":2}'
		"└─> return 42 from myfunc"
		]
	)()

# ---------------------------------------------------------------------------

(() ->
	lLines = []
	obj = {
		first: "this is the first item in the hash"
		second: "this is the second item in the hash"
		}
	debug 'enter myfunc'
	debug 'something'
	debug 'obj', obj
	debug 'return 42 from myfunc'
	simple.equal {{LINE}}, lLines, [
		"enter myfunc"
		"│   something"
		"│   obj:"
		"│      ---"
		"│      first: this is the first item in the hash"
		"│      second: this is the second item in the hash"
		"└─> return 42 from myfunc"
		]
	)()

# ---------------------------------------------------------------------------
# --- Test ability to debug only a particular function

(() ->
	lLines = []
	resetDebugging 'innerFunc'
#	setDebugging 'innerFunc'

	debug "enter myfunc"
	debug "something"
	debug "enter innerFunc"
	debug "something else"
	debug "return nothing from innerFunc"
	debug "this should not appear"
	debug "return 42 from myfunc"
	simple.equal {{LINE}}, lLines, [
		"enter innerFunc"
		"│   something else"
		"└─> return nothing from innerFunc"
		]
	setDebugging false
	)()

# ---------------------------------------------------------------------------
# --- Test ability to debug only a particular function
#     using actual functions!

(() ->
	lLines = []
	resetDebugging 'innerFunc'
#	setDebugging 'innerFunc'

	innerFunc = () ->

		debug "enter innerFunc()"
		debug "answer is 42"
		x = 42
		debug "return from innerFunc()"
		return

	outerFunc = () ->

		debug "enter outerFunc()"
		innerFunc()
		debug "return from outerFunc()"
		return

	outerFunc()

	simple.equal {{LINE}}, lLines, [
		"enter innerFunc()"
		"│   answer is 42"
		"└─> return from innerFunc()"
		]
	setDebugging false
	)()

# ---------------------------------------------------------------------------

(() ->
	simple.truthy {{LINE}}, funcMatch('get', ['get'])
	simple.truthy {{LINE}}, funcMatch('StringInput.get', ['get'])
	)()

# ---------------------------------------------------------------------------

(() ->
	resetDebugging true
#	setDebugging true
	lLines = []

	line = 'first line'
	debug "line is #{OL(line)}"

	simple.equal {{LINE}}, lLines.length, 1
	simple.equal {{LINE}}, lLines, [
		"line is 'first line'"
		]
	setDebugging false
	)()

# ---------------------------------------------------------------------------

(() ->
	resetDebugging true
#	setDebugging true
	lLines = []

	obj = {
		first: "this is the first item in the hash"
		second: "this is the second item in the hash"
		}

	debug 'enter myfunc'
	debug 'return from myfunc', obj
	debug "Answer is 42"
	simple.equal {{LINE}}, lLines, [
		"enter myfunc"
		"└─> return from myfunc:"
		"       ---"
		"       first: this is the first item in the hash"
		"       second: this is the second item in the hash"
		"Answer is 42"
		]
	)()

# ---------------------------------------------------------------------------

(() ->
	resetDebugging true
#	setDebugging true
	lLines = []

	longBlock = """
		this is one very long line
		this is another very long line
		"""

	debug 'enter myfunc'
	debug 'return from myfunc', longBlock
	debug "Answer is 42"
	simple.equal {{LINE}}, lLines, [
		"enter myfunc"
		"└─> return from myfunc:"
		"    =========================================="
		"    this is one very long line"
		"    this is another very long line"
		"    =========================================="
		"Answer is 42"
		]
	)()

# ---------------------------------------------------------------------------

(() ->
	resetDebugging 'get'

	block = """
		enter myfunc
		enter get
		enter fetch
		return from fetch
		return from get
		enter nofunc
		return from nofunc
		enter get
		something
		return from get
		return from myfunc
		"""

	tester.equal {{LINE}}, block, """
		enter get
		│   enter fetch
		│   └─> return from fetch
		└─> return from get
		enter get
		│   something
		└─> return from get
		"""
	)()

# ---------------------------------------------------------------------------
#     Use new functions: funcDoDebug and funcDoLog

(() ->
	resetDebugging (funcName, debugOn) -> debugOn || (funcName=='get')

	block = """
		enter myfunc
		enter get
		enter fetch
		return from fetch
		return from get
		enter nofunc
		return from nofunc
		enter get
		something
		return from get
		return from myfunc
		"""

	tester.equal {{LINE}}, block, """
		enter get
		│   enter fetch
		│   └─> return from fetch
		└─> return from get
		enter get
		│   something
		└─> return from get
		"""
	)()

# ---------------------------------------------------------------------------
#     Use new functions: funcDoDebug and funcDoLog

(() ->
	resetDebugging (funcName) -> (funcName=='get')

	block = """
		enter myfunc
		enter get
		enter fetch
		return from fetch
		return from get
		enter nofunc
		return from nofunc
		enter get
		something
		return from get
		return from myfunc
		"""

	tester.equal {{LINE}}, block, """
		enter get
		└─> return from get
		enter get
		│   something
		└─> return from get
		"""
	)()

# ---------------------------------------------------------------------------
#     Test debugging object methods

(() ->
	class StrInput

		mapArray: (lLines) ->
			result = ''
			for line in lLines
				result += @mapLine(line)
				result += "\n"
			return result

		mapLine: (line, level) ->

			debug "enter StrInput.mapLine()"
			assert line? && isString(line), "StrInput.mapLine(): not a string"
			line = "> #{line}"
			debug "return #{OL(line)} from StrInput.mapLine()"
			return line

	resetDebugging true
	lLines = []
	input = new StrInput()
	result = input.mapArray(['abc','def'])
	simple.equal 374, result, "> abc\n> def\n"
	simple.equal 375, lLines, [
		'enter StrInput.mapLine()',
		"└─> return '> abc' from StrInput.mapLine()",
		'enter StrInput.mapLine()',
		"└─> return '> def' from StrInput.mapLine()"
		]
	)()
