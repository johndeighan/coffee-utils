# block.test.cielo

import {assert} from '@jdeighan/exceptions'
import {LOG} from '@jdeighan/exceptions/log'

import {utest} from '@jdeighan/unit-tester'
import {undef} from '@jdeighan/coffee-utils'
import {
	blockToArray, arrayToBlock, toArray, toBlock,
	firstLine, remainingLines,
	normalizeBlock, truncateBlock,
	joinBlocks, forEachLine, forEachBlock, forEachSetOfBlocks,
	} from '@jdeighan/coffee-utils/block'
import {mydir, mkpath} from '@jdeighan/coffee-utils/fs'

testDir = mydir(`import.meta.url`)

# ---------------------------------------------------------------------------

utest.equal {{LINE}}, blockToArray("abc\nxyz\n"), [
	'abc'
	'xyz'
	]

utest.equal {{LINE}}, blockToArray("abc\nxyz\n\n\n\n"), [
	'abc'
	'xyz'
	]

utest.equal {{LINE}}, blockToArray("abc\n\nxyz\n"), [
	'abc'
	''
	'xyz'
	]

# ---------------------------------------------------------------------------

utest.equal {{LINE}}, toArray("abc\nxyz"), [
	'abc'
	'xyz'
	]

utest.equal {{LINE}}, toArray("""
	abc
	xyz
	"""), [
	'abc'
	'xyz'
	]

utest.equal {{LINE}}, toArray("""
	abc
	xyz
	""", 'noEmptyLines'), [
	'abc'
	'xyz'
	]

utest.equal {{LINE}}, toArray("""
	start   tag        start
	start   '#if'      if1
	start   EOF        end
	if1     tag        start   {/if}
	if1     '#elsif'   if1
	if1     EOF        end     {/if}
	if1     '#else'    if2
	if2     tag        start   {/if}
	if2     '#if'      if1     {/if}
	if2     EOF        end     {/if}
	"""), [
	"start   tag        start"
	"start   '#if'      if1"
	"start   EOF        end"
	"if1     tag        start   {/if}"
	"if1     '#elsif'   if1"
	"if1     EOF        end     {/if}"
	"if1     '#else'    if2"
	"if2     tag        start   {/if}"
	"if2     '#if'      if1     {/if}"
	"if2     EOF        end     {/if}"
	]

utest.equal {{LINE}}, toArray("""
	start   tag        start
	start   '#if'      if1
	start   EOF        end
	if1     tag        start   {/if}
	if1     '#elsif'   if1
	if1     EOF        end     {/if}
	if1     '#else'    if2
	if2     tag        start   {/if}
	if2     '#if'      if1     {/if}
	if2     EOF        end     {/if}
	""", 'noEmptyLines'), [
	"start   tag        start"
	"start   '#if'      if1"
	"start   EOF        end"
	"if1     tag        start   {/if}"
	"if1     '#elsif'   if1"
	"if1     EOF        end     {/if}"
	"if1     '#else'    if2"
	"if2     tag        start   {/if}"
	"if2     '#if'      if1     {/if}"
	"if2     EOF        end     {/if}"
	]

utest.equal {{LINE}}, toArray("abc\n\nxyz"), [
	'abc'
	''
	'xyz'
	]

utest.equal {{LINE}}, toArray("abc\n\n\nxyz\n"), [
	'abc'
	''
	''
	'xyz'
	''
	]

utest.equal {{LINE}}, toArray("abc\n \nxyz", 'noEmptyLines'), [
	'abc'
	'xyz'
	]

utest.equal {{LINE}}, toArray("abc\n \nxyz", 'noLeadingEmptyLines'), [
	'abc'
	''
	'xyz'
	]

# ... pass in an array

utest.equal {{LINE}}, toArray(["abc", "xyz"]), [
	'abc'
	'xyz'
	]

utest.equal {{LINE}}, toArray(["abc", "", "xyz"]), [
	'abc'
	''
	'xyz'
	]

utest.equal {{LINE}}, toArray(["abc", "", "", "xyz", ""]), [
	'abc'
	''
	''
	'xyz'
	''
	]

utest.equal {{LINE}}, toArray(["abc", "", "xyz"], 'noEmptyLines'), [
	'abc'
	'xyz'
	]

utest.equal {{LINE}}, toArray(["abc", " ", "xyz"], 'noLeadingEmptyLines'), [
	'abc'
	''
	'xyz'
	]

# ... pass in an array, some strings have newlines

utest.equal {{LINE}}, toArray(["abc\ndef", "", "xyz"], 'noEmptyLines'), [
	'abc'
	'def'
	'xyz'
	]

utest.equal {{LINE}}, toArray(["abc\ndef", "", "xyz"], 'noLeadingEmptyLines'), [
	'abc'
	'def'
	''
	'xyz'
	]

utest.equal {{LINE}}, toArray(["", "abc\ndef", "", "xyz"], 'noLeadingEmptyLines'), [
	'abc'
	'def'
	''
	'xyz'
	]

utest.equal {{LINE}}, toArray(["", "", "abc\ndef", "", "xyz"], 'noLeadingEmptyLines'), [
	'abc'
	'def'
	''
	'xyz'
	]


# ---------------------------------------------------------------------------

utest.equal {{LINE}}, toArray(['abc','xyz']), [
	'abc'
	'xyz'
	]

utest.equal {{LINE}}, toArray(['abc','xyz','']), [
	'abc'
	'xyz'
	''
	]

utest.equal {{LINE}}, toArray(['abc','','xyz']), [
	'abc'
	''
	'xyz'
	]

# ---------------------------------------------------------------------------
# --- MUST also split internal strings

utest.equal {{LINE}}, toArray(['abc\ndef', 'ghi']), [
	'abc'
	'def'
	'ghi'
	]

# ---------------------------------------------------------------------------
# --- test toBlock()

utest.equal {{LINE}}, toBlock(undef), undef
utest.equal {{LINE}}, toBlock([]), ""
utest.equal {{LINE}}, toBlock([""]), ""
utest.equal {{LINE}}, toBlock(["", ""]), "\n"
utest.equal {{LINE}}, toBlock(['a', 'b', 'c']), "a\nb\nc"
utest.equal {{LINE}}, toBlock(['a ', 'b ', 'c ']), "a\nb\nc"

# ---------------------------------------------------------------------------

utest.equal {{LINE}}, arrayToBlock(['a','b','c']), "a\nb\nc"
utest.equal {{LINE}}, arrayToBlock(['a',undef,'b','c']), "a\nb\nc"
utest.equal {{LINE}}, arrayToBlock([undef,'a','b','c',undef]), "a\nb\nc"

# ---------------------------------------------------------------------------

utest.equal {{LINE}}, firstLine("""
	#starbucks
	do this
	do that
	"""), '#starbucks'

# ---------------------------------------------------------------------------

utest.equal {{LINE}}, remainingLines("""
	#starbucks
	do this
	do that
	"""), """
	do this
	do that
	"""

# ---------------------------------------------------------------------------

(() ->
	str = joinBlocks('import me', '', 'do this\ndo that')
	utest.equal {{LINE}}, str, """
		import me
		do this
		do that
		"""
	)()

utest.equal {{LINE}}, joinBlocks('a', 'b'), "a\nb"
utest.equal {{LINE}}, joinBlocks(['a', 'b']), "a\nb"
# utest.equal {{LINE}}, joinBlocks([['a', 'b']]), "a\nb"
utest.equal {{LINE}}, joinBlocks(['a'], ['b']), "a\nb"

# ---------------------------------------------------------------------------

utest.equal {{LINE}}, normalizeBlock("""
	line 1
	line 2
	"""), """
	line 1
	line 2
	"""

utest.equal {{LINE}}, normalizeBlock("""
	line 1

	line 2
	"""), """
	line 1
	line 2
	"""

utest.equal {{LINE}}, normalizeBlock("""

	line 1

	line 2


	"""), """
	line 1
	line 2
	"""

# ---------------------------------------------------------------------------

utest.equal {{LINE}}, truncateBlock("""
	line 1
	line 2
	line 3
	line 4
	""", 2), """
	line 1
	line 2
	"""

# ---------------------------------------------------------------------------

(() ->
	lBlocks = [
		"import {say} from '@jdeighan/coffee-utils'",
		"",
		"<script>\n\tx = 42\n</script>",
		"",
		]
	str = joinBlocks(lBlocks...)
	utest.equal {{LINE}}, str, """
		import {say} from '@jdeighan/coffee-utils'
		<script>
			x = 42
		</script>
		"""
	)()

# ---------------------------------------------------------------------------

(() ->
	lImports = [
		"import {say} from '@jdeighan/coffee-utils'",
		]
	code = """
		if (x==42)
			LOG "line 2 in unit test"
		"""
	str = joinBlocks(lImports..., code)
	utest.equal {{LINE}}, str, """
		import {say} from '@jdeighan/coffee-utils'
		if (x==42)
			LOG "line 2 in unit test"
		"""
	)()

# ---------------------------------------------------------------------------
# test forEachLine()

(() ->
	lLines = []

	callback = (line) ->
		lLines.push line
		return

	filepath = "c:/Users/johnd/coffee-utils/test/data/file2.txt"
	await forEachLine filepath, callback

	utest.equal {{LINE}}, lLines, [
		"abc",
		"def",
		"ghi",
		"jkl",
		]
	)()

# ---------------------------------------------------------------------------
# test forEachBlock()

(() ->
	lBlocks = []

	callback = (block) ->
		lBlocks.push block
		return

	filepath = "c:/Users/johnd/coffee-utils/test/data/file3.txt"
	await forEachBlock filepath, callback

	utest.equal {{LINE}}, lBlocks, [
		"abc\ndef",
		"abc\ndef\nghi",
		"abc\ndef\nghi\njkl",
		]
	)()

# ----------------------------------------------------------------------------

(() ->
	filepath = mkpath(testDir, 'code2.test.txt')
	lFirstBlocks = undef
	callback = (lBlocks) ->
		lFirstBlocks = lBlocks
		return true   # we're only interested in the first set

	await forEachSetOfBlocks filepath, callback
	utest.equal lFirstBlocks, ["f()", "f"]
	)()

# ----------------------------------------------------------------------------

(() ->
	filepath = mkpath(testDir, 'code2.test.txt')
	lAllBlockSets = []
	callback = (lBlocks) ->
		lAllBlockSets.push(lBlocks)
		return

	await forEachSetOfBlocks filepath, callback
	utest.equal lAllBlockSets, [
			["f()", "f"],
			["f = (key=undef) ->\n\tswitch key\n\t\twhen 'ok'\n\t\t\tsay 'all is OK'", "f,say,mkpath"],
			]
	)()
