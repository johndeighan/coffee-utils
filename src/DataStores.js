// Generated by CoffeeScript 2.7.0
// DataStores.coffee
import pathlib from 'path';

import {
  writable,
  readable,
  get
} from 'svelte/store';

import {
  assert,
  croak
} from '@jdeighan/base-utils';

import {
  undef,
  pass
} from '@jdeighan/coffee-utils';

import {
  localStore
} from '@jdeighan/coffee-utils/browser';

import {
  withExt,
  slurp,
  barf,
  newerDestFileExists
} from '@jdeighan/coffee-utils/fs';

import {
  fromTAML
} from '@jdeighan/coffee-utils/taml';

import {
  createDraft,
  finishDraft,
  produce
} from 'immer';

// ---------------------------------------------------------------------------
export var WritableDataStore = class WritableDataStore {
  constructor(value = undef) {
    this.store = writable(value);
  }

  subscribe(func) {
    return this.store.subscribe(func);
  }

  set(value) {
    return this.store.set(value);
  }

  update(func) {
    return this.store.update(func);
  }

};

// ---------------------------------------------------------------------------
export var BaseDataStore = class BaseDataStore {
  constructor(value1 = undef) {
    this.value = value1;
    this.lSubscribers = [];
  }

  subscribe(func) {
    func(this.value);
    this.lSubscribers.push(func);
    return function() {
      var pos;
      pos = this.lSubscribers.indexOf(func);
      return this.lSubscribers.splice(pos, 1);
    };
  }

  set(val) {
    this.value = val;
    this.alertSubscribers();
  }

  update(func) {
    this.value = func(this.value);
    this.alertSubscribers();
  }

  alertSubscribers() {
    var func, i, len, ref;
    ref = this.lSubscribers;
    for (i = 0, len = ref.length; i < len; i++) {
      func = ref[i];
      func(this.value);
    }
  }

};

// ---------------------------------------------------------------------------
export var ImmerDataStore = class ImmerDataStore extends BaseDataStore {
  constructor() {
    super([]); // initialize with an empty array
  }

  getNewState() {
    return produce(state, draft(() => {
      return this.addGift(draft, description, image);
    }));
  }

  addGift(draft, description, image) {
    return draft.push({
      id: 1,
      description,
      image
    });
  }

};

// ---------------------------------------------------------------------------
export var ToDoDataStore = class ToDoDataStore {
  // --- implemented with immer
  constructor() {
    this.lToDos = [];
    this.lSubscribers = [];
  }

  subscribe(func) {
    func(this.lToDos);
    this.lSubscribers.push(func);
    return function() {
      var index;
      index = this.lSubscribers.indexOf(func);
      return this.lSubscribers.splice(index, 1);
    };
  }

  alertSubscribers() {
    var func, i, len, ref;
    ref = this.lSubscribers;
    for (i = 0, len = ref.length; i < len; i++) {
      func = ref[i];
      func(this.lToDos);
    }
  }

  set(value) {
    // --- Set new value
    return this.alertSubscribers();
  }

  update(func) {
    // --- Update value
    return this.alertSubscribers();
  }

  add(name) {
    this.lToDos.push({
      text: name,
      done: false
    });
  }

};

// ---------------------------------------------------------------------------
export var LocalStorageDataStore = class LocalStorageDataStore extends WritableDataStore {
  constructor(masterKey1, defValue = undef) {
    var value;
    super(defValue);
    this.masterKey = masterKey1;
    value = localStore(this.masterKey);
    if (value != null) {
      this.set(value);
    }
  }

  // --- I'm assuming that when update() is called,
  //     set() will also be called
  set(value) {
    if (value == null) {
      croak("LocalStorageStore.set(): cannont set to undef");
    }
    super.set(value);
    return localStore(this.masterKey, value);
  }

  update(func) {
    super.update(func);
    return localStore(this.masterKey, get(this.store));
  }

};

// ---------------------------------------------------------------------------
export var PropsDataStore = class PropsDataStore extends LocalStorageDataStore {
  constructor(masterKey) {
    super(masterKey, {});
  }

  setProp(name, value) {
    if (name == null) {
      croak("PropStore.setProp(): empty key");
    }
    return this.update(function(hPrefs) {
      hPrefs[name] = value;
      return hPrefs;
    });
  }

};

// ---------------------------------------------------------------------------
export var ReadableDataStore = class ReadableDataStore {
  constructor() {
    this.store = readable(null, function(set) {
      this.setter = set; // store the setter function
      this.start(); // call your start() method
      return () => {
        return this.stop(); // return function capable of stopping
      };
    });
  }

  subscribe(callback) {
    return this.store.subscribe(callback);
  }

  start() {
    return pass;
  }

  stop() {
    return pass;
  }

};

// ---------------------------------------------------------------------------
export var DateTimeDataStore = class DateTimeDataStore extends ReadableDataStore {
  start() {
    // --- We need to store this interval for use in stop() later
    return this.interval = setInterval(function() {
      return this.setter(new Date(), 1000);
    });
  }

  stop() {
    return clearInterval(this.interval);
  }

};

// ---------------------------------------------------------------------------
export var MousePosDataStore = class MousePosDataStore extends ReadableDataStore {
  start() {
    // --- We need to store this handler for use in stop() later
    this.mouseMoveHandler = function(e) {
      return this.setter({
        x: e.clientX,
        y: e.clientY
      });
    };
    return document.body.addEventListener('mousemove', this.mouseMoveHandler);
  }

  stop() {
    return document.body.removeEventListener('mousemove', this.mouseMoveHandler);
  }

};

// ---------------------------------------------------------------------------
export var TAMLDataStore = class TAMLDataStore extends WritableDataStore {
  constructor(str) {
    super(fromTAML(str));
  }

};

// ---------------------------------------------------------------------------
//         UTILITIES
// ---------------------------------------------------------------------------
export var brewTamlStr = function(code, stub) {
  return `import {TAMLDataStore} from '@jdeighan/starbucks/stores';

export let ${stub} = new TAMLDataStore(\`${code}\`);`;
};

// ---------------------------------------------------------------------------
export var brewTamlFile = function(srcPath, destPath = undef, hOptions = {}) {
  var hInfo, jsCode, stub, tamlCode;
  if (destPath == null) {
    destPath = withExt(srcPath, '.js', {
      removeLeadingUnderScore: true
    });
  }
  if (hOptions.force || !newerDestFileExists(srcPath, destPath)) {
    hInfo = pathlib.parse(destPath);
    stub = hInfo.name;
    tamlCode = slurp(srcPath);
    jsCode = brewTamlStr(tamlCode, stub);
    barf(destPath, jsCode);
  }
};

// ---------------------------------------------------------------------------
