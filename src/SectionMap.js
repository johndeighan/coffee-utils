// Generated by CoffeeScript 2.7.0
// SectionMap.coffee
var isSectionName, isSetName;

import {
  assert,
  pass,
  undef,
  defined,
  croak,
  OL,
  isEmpty,
  nonEmpty,
  isString,
  isHash,
  isArray,
  isUniqueTree,
  isNonEmptyString
} from '@jdeighan/coffee-utils';

import {
  arrayToBlock
} from '@jdeighan/coffee-utils/block';

import {
  indented
} from '@jdeighan/coffee-utils/indent';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  Section
} from '@jdeighan/coffee-utils/section';

// ---------------------------------------------------------------------------
isSectionName = function(name) {
  return isString(name) && name.match(/^[a-z][a-z0-9]*/);
};

// ---------------------------------------------------------------------------
isSetName = function(name) {
  return isString(name) && name.match(/^[A-Z][a-z0-9]*/);
};

// ---------------------------------------------------------------------------
export var SectionMap = class SectionMap {
  constructor(lSectionTree) {
    // --- lSectionTree is a tree of section names
    debug("enter SectionMap()", lSectionTree);
    this.lSectionTree = lSectionTree; // a tree of section names
    this.hSets = {};
    this.hSections = {};
    this.addSections(lSectionTree);
    debug("return from SectionMap()", this.hSections);
  }

  // ..........................................................

    // --- TODO: Allow array to start with a set name ---
  addSections(desc) {
    var i, item, j, k, lAdded, lParts, len, len1, name;
    // --- returns a flat array of sections that were added
    if (isString(desc)) {
      assert(nonEmpty(desc), "empty section name");
      assert(isSectionName(desc), `bad section name ${OL(desc)}`);
      assert(this.hSections[desc] === undef, `duplicate section ${OL(desc)}`);
      this.hSections[desc] = new Section();
      return [desc];
    } else {
      assert(isArray(desc), `not an array or string ${OL(desc)}`);
      name = undef;
      lParts = [];
      for (i = j = 0, len = desc.length; j < len; i = ++j) {
        item = desc[i];
        if ((i === 0) && isSetName(item)) {
          name = item;
        } else {
          lAdded = this.addSections(item);
          for (k = 0, len1 = lAdded.length; k < len1; k++) {
            item = lAdded[k];
            lParts.push(item);
          }
        }
      }
      if (defined(name)) {
        this.addSet(name, lParts);
      }
      return lParts;
    }
  }

  // ..........................................................
  // --- a generator - yield order is not guaranteed
  * allSections(desc) {
    var _, j, k, lNames, len, len1, name, ref, ref1, sect;
    debug("enter allSections()");
    if (desc === undef) {
      // --- We want to return all sections
      debug("yield all sections");
      ref = this.hSections;
      for (_ in ref) {
        sect = ref[_];
        yield sect;
      }
    } else if (isString(desc)) {
      if (isSectionName(desc)) {
        debug(`yield section ${OL(desc)}`);
        yield this.section(desc);
      } else if (isSetName(desc)) {
        debug(`expand set ${OL(desc)}`);
        debug('hSets', this.hSets);
        lNames = this.hSets[desc];
        assert(defined(lNames), `no set named ${OL(desc)}`);
        debug(`set ${desc}`, lNames);
        for (j = 0, len = lNames.length; j < len; j++) {
          name = lNames[j];
          debug(`yield section ${OL(desc)}`);
          yield this.section(name);
        }
      } else {
        croak(`bad name ${OL(desc)}`);
      }
    } else {
      assert(isArray(desc), "not an array");
      for (k = 0, len1 = desc.length; k < len1; k++) {
        name = desc[k];
        debug(`yield section ${OL(name)}`);
        assert(isString(name), `not a string ${OL(name)}`);
        if (isSectionName(name)) {
          yield this.section(name);
        } else if (isSetName(name)) {
          ref1 = this.hSets[name];
          for (_ in ref1) {
            sect = ref1[_];
            yield sect;
          }
        } else {
          croak(`bad name ${OL(name)}`);
        }
      }
    }
    debug("return from allSections()");
  }

  // ..........................................................
  addSet(name, lSectionTree) {
    var j, len, secName;
    debug("enter addSet()", name, lSectionTree);
    // --- check the name
    assert(isSetName(name), `not a valid set name ${OL(name)}`);
    // --- check lSectionTree
    assert(isArray(lSectionTree), "arg 2 not an array");
    for (j = 0, len = lSectionTree.length; j < len; j++) {
      secName = lSectionTree[j];
      assert(isNonEmptyString(secName), `not a non-empty string ${OL(secName)}`);
      assert(defined(this.hSections[secName]), `not a section name ${OL(secName)}`);
    }
    this.hSets[name] = lSectionTree;
    debug('hSets', this.hSets);
    debug("return from addSet()");
  }

  // ..........................................................
  section(name) {
    var sect;
    sect = this.hSections[name];
    assert(defined(sect), `No section named ${OL(name)}`);
    return sect;
  }

  // ..........................................................
  firstSection(name) {
    var lSectionTree;
    assert(isSetName(name), `bad set name ${OL(name)}`);
    lSectionTree = this.hSets[name];
    assert(defined(lSectionTree), `no such set ${OL(name)}`);
    assert(nonEmpty(lSectionTree), `empty section ${OL(name)}`);
    return this.section(lSectionTree[0]);
  }

  // ..........................................................
  lastSection(name) {
    var lSectionTree;
    assert(isSetName(name), `bad set name ${OL(name)}`);
    lSectionTree = this.hSets[name];
    assert(defined(lSectionTree), `no such set ${OL(name)}`);
    assert(nonEmpty(lSectionTree), `empty section ${OL(name)}`);
    return this.section(lSectionTree[lSectionTree.length - 1]);
  }

  // ..........................................................
  length(desc = undef) {
    var ref, result, sect;
    result = 0;
    ref = this.allSections(desc);
    for (sect of ref) {
      result += sect.length();
    }
    return result;
  }

  // ..........................................................
  isEmpty(desc = undef) {
    return this.length(desc) === 0;
  }

  // ..........................................................
  nonEmpty(desc = undef) {
    return this.length(desc) > 0;
  }

  // ..........................................................
  indent(desc = undef, level = 1) {
    var ref, sect;
    ref = this.allSections(desc);
    for (sect of ref) {
      sect.indent(level);
    }
  }

  // ..........................................................
  enclose(name, pre, post) {
    var sect;
    if (isSectionName(name)) {
      sect = this.section(name);
      if (sect.nonEmpty()) {
        sect.indent();
        sect.prepend(pre);
        sect.add(post);
      }
    } else if (isSetName(name)) {
      if (this.nonEmpty(name)) {
        this.indent(name);
        this.firstSection(name).prepend(pre);
        this.lastSection(name).add(post);
      }
    } else {
      croak(`Bad name param ${OL(name)}`);
    }
  }

  // ..........................................................
  getBlock() {
    var result;
    debug("enter getBlock()");
    this.lAllBlocks = [];
    debug('lSectionTree', this.lSectionTree);
    this.accumBlock(this.lSectionTree);
    debug('lAllBlocks', this.lAllBlocks);
    result = arrayToBlock(this.lAllBlocks);
    debug("return from getBlock()", result);
    return result;
  }

  // ..........................................................
  accumBlock(tree) {
    var block, j, len, subtree;
    if (isString(tree)) {
      debug(`accumBlock ${OL(tree)}`);
      block = this.section(tree).getBlock();
      if (nonEmpty(block)) {
        this.lAllBlocks.push(block);
      }
    } else {
      assert(isArray(tree), "not an array");
      for (j = 0, len = tree.length; j < len; j++) {
        subtree = tree[j];
        this.accumBlock(subtree);
      }
    }
  }

  // ..........................................................
  getShape() {
    var result;
    debug("enter getShape()");
    this.lAllShapes = [];
    debug('lSectionTree', this.lSectionTree);
    this.accumShape(this.lSectionTree, -1);
    debug('lAllShapes', this.lAllShapes);
    result = arrayToBlock(this.lAllShapes);
    debug("return from getShape()", result);
    return result;
  }

  // ..........................................................
  accumShape(tree, level) {
    var j, lSections, len, strSections, subtree;
    if (isSectionName(tree)) {
      debug(`accumShape ${OL(tree)}`);
      this.lAllShapes.push(indented(tree, level));
    } else if (isSetName(tree)) {
      lSections = this.hSets[tree];
      strSections = lSections.join(', ');
      debug(`accumShape SET: ${OL(tree)} = ${strSections}`);
      this.lAllShapes.push(indented(`SET: ${tree} = ${strSections}`, level));
    } else {
      assert(isArray(tree), "not an array");
      for (j = 0, len = tree.length; j < len; j++) {
        subtree = tree[j];
        this.accumShape(subtree, level + 1);
      }
    }
  }

};
