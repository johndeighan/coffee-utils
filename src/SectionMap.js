// Generated by CoffeeScript 2.7.0
// SectionMap.coffee
var isSectionName, isSetName;

import {
  assert,
  error,
  croak
} from '@jdeighan/unit-tester/utils';

import {
  pass,
  undef,
  defined,
  OL,
  isEmpty,
  nonEmpty,
  isString,
  isHash,
  isArray,
  isUniqueTree,
  isNonEmptyString,
  isNonEmptyArray
} from '@jdeighan/coffee-utils';

import {
  arrayToBlock
} from '@jdeighan/coffee-utils/block';

import {
  indented
} from '@jdeighan/coffee-utils/indent';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  Section
} from '@jdeighan/coffee-utils/section';

// ---------------------------------------------------------------------------
isSectionName = function(name) {
  return isString(name) && name.match(/^[a-z][a-z0-9]*/);
};

// ---------------------------------------------------------------------------
isSetName = function(name) {
  return isString(name) && name.match(/^[A-Z][a-z0-9]*/);
};

// ---------------------------------------------------------------------------
export var SectionMap = class SectionMap {
  constructor(lSectionTree) {
    // --- lSectionTree is a tree of section names
    debug("enter SectionMap()", lSectionTree);
    this.lSectionTree = lSectionTree; // a tree of section names
    this.hSets = {};
    this.hSections = {};
    this.addSections(lSectionTree);
    debug("return from SectionMap()", this.hSections);
  }

  // ..........................................................
  addSections(desc) {
    var i, item, j, k, lAdded, lParts, len, len1, name;
    // --- returns a flat array of sections that were added
    if (isString(desc)) {
      assert(nonEmpty(desc), "empty section name");
      assert(isSectionName(desc), `bad section name ${OL(desc)}`);
      assert(this.hSections[desc] === undef, `duplicate section ${OL(desc)}`);
      this.hSections[desc] = new Section(desc);
      return [desc];
    } else {
      assert(isArray(desc), `not an array or string ${OL(desc)}`);
      name = undef;
      lParts = [];
      for (i = j = 0, len = desc.length; j < len; i = ++j) {
        item = desc[i];
        if ((i === 0) && isSetName(item)) {
          name = item;
        } else {
          lAdded = this.addSections(item);
          for (k = 0, len1 = lAdded.length; k < len1; k++) {
            item = lAdded[k];
            lParts.push(item);
          }
        }
      }
      if (defined(name)) {
        this.addSet(name, lParts);
      }
      return lParts;
    }
  }

  // ..........................................................
  addSet(name, lSectionTree) {
    var j, len, secName;
    debug("enter addSet()", name, lSectionTree);
    // --- check the name
    assert(isSetName(name), `not a valid set name ${OL(name)}`);
    // --- check lSectionTree
    assert(isArray(lSectionTree), "arg 2 not an array");
    for (j = 0, len = lSectionTree.length; j < len; j++) {
      secName = lSectionTree[j];
      assert(isNonEmptyString(secName), `not a non-empty string ${OL(secName)}`);
      assert(defined(this.hSections[secName]), `not a section name ${OL(secName)}`);
    }
    this.hSets[name] = lSectionTree;
    debug('hSets', this.hSets);
    debug("return from addSet()");
  }

  // ..........................................................
  // --- sections returned in depth-first order from section tree
  //     Set names are simply skipped
  //     yields: [<level>, <section>]
  * allSections(desc = undef, level = 0) {
    var item, j, lTree, len, result;
    debug("enter allSections()", desc, level);
    if (desc === undef) {
      desc = this.lSectionTree;
    }
    if (isArray(desc)) {
      for (j = 0, len = desc.length; j < len; j++) {
        item = desc[j];
        if (isSectionName(item)) {
          result = [level, this.section(item)];
          debug('yield', result);
          yield result;
        } else if (isSetName(item)) {
          pass;
        } else {
          assert(isArray(item), `not an array ${OL(item)}`);
          yield* this.allSections(item, level + 1);
        }
      }
    } else if (isSectionName(desc)) {
      result = [level, this.section(desc)];
      debug('yield', result);
      yield result;
    } else if (isSetName(desc)) {
      lTree = this.hSets[desc];
      assert(defined(lTree), `Not a Set: ${OL(desc)}`);
      yield* this.allSections(lTree, level);
    } else {
      croak(`Bad item: ${OL(desc)}`);
    }
    debug("return from allSections()");
  }

  // ..........................................................
  // --- hProc should be <name> -> <function>
  //     <function> should be <block> -> <block>
  // --- lTree allows you to get just a section
  getBlock(hProc = {}, lTree = undef) {
    var block, j, lParts, len, part, result;
    debug("enter getBlock()");
    if (lTree === undef) {
      lTree = this.lSectionTree;
    } else {
      assert(isArray(lTree), `not an array ${OL(lTree)}`);
    }
    lParts = [];
    for (j = 0, len = lTree.length; j < len; j++) {
      part = lTree[j];
      if (isString(part)) {
        block = this.section(part).getBlock();
        if (defined(hProc[part])) {
          // --- called even if block is empty
          block = hProc[part](block);
        }
      } else if (isNonEmptyArray(part)) {
        if (isSectionName(part[0])) {
          block = this.getBlock(hProc, part);
        } else if (isSetName(part[0])) {
          block = this.getBlock(hProc, part.slice(1));
          if (defined(hProc[part[0]])) {
            block = hProc[part[0]](block);
          }
        } else {
          croak(`Bad part: ${OL(part)}`);
        }
      } else {
        croak(`Bad part: ${OL(part)}`);
      }
      if (defined(block)) {
        lParts.push(block);
      }
    }
    debug('lParts', lParts);
    result = arrayToBlock(lParts);
    debug("return from getBlock()", result);
    return result;
  }

  // ..........................................................
  section(name) {
    var sect;
    sect = this.hSections[name];
    assert(defined(sect), `No section named ${OL(name)}`);
    return sect;
  }

  // ..........................................................
  firstSection(name) {
    var lSectionTree;
    assert(isSetName(name), `bad set name ${OL(name)}`);
    lSectionTree = this.hSets[name];
    assert(defined(lSectionTree), `no such set ${OL(name)}`);
    assert(nonEmpty(lSectionTree), `empty section ${OL(name)}`);
    return this.section(lSectionTree[0]);
  }

  // ..........................................................
  lastSection(name) {
    var lSectionTree;
    assert(isSetName(name), `bad set name ${OL(name)}`);
    lSectionTree = this.hSets[name];
    assert(defined(lSectionTree), `no such set ${OL(name)}`);
    assert(nonEmpty(lSectionTree), `empty section ${OL(name)}`);
    return this.section(lSectionTree[lSectionTree.length - 1]);
  }

  // ..........................................................
  length(desc = undef) {
    var _, ref, result, sect, x;
    result = 0;
    ref = this.allSections(desc);
    for (x of ref) {
      [_, sect] = x;
      result += sect.length();
    }
    return result;
  }

  // ..........................................................
  isEmpty(desc = undef) {
    return this.length(desc) === 0;
  }

  // ..........................................................
  nonEmpty(desc = undef) {
    return this.length(desc) > 0;
  }

  // ..........................................................
  getShape() {
    var lParts, level, ref, result, sect, x;
    debug("enter getShape()");
    lParts = [];
    ref = this.allSections();
    for (x of ref) {
      [level, sect] = x;
      lParts.push(indented(sect.name, level));
    }
    result = arrayToBlock(lParts);
    debug("return from getShape()", result);
    return result;
  }

};
