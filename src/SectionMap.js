// Generated by CoffeeScript 2.7.0
// SectionMap.coffee
var isSectionName, isSetName;

import {
  assert,
  pass,
  undef,
  defined,
  croak,
  OL,
  isEmpty,
  nonEmpty,
  isString,
  isHash,
  isArray,
  isUniqueTree,
  isNonEmptyString
} from '@jdeighan/coffee-utils';

import {
  arrayToBlock
} from '@jdeighan/coffee-utils/block';

import {
  debug
} from '@jdeighan/coffee-utils/debug';

import {
  Section
} from '@jdeighan/coffee-utils/section';

// ---------------------------------------------------------------------------
isSectionName = function(name) {
  assert(isString(name), "not a string");
  return name.match(/^[a-z][a-z0-9]*/);
};

// ---------------------------------------------------------------------------
isSetName = function(name) {
  assert(isString(name), "not a string");
  return name.match(/^[A-Z][a-z0-9]*/);
};

// ---------------------------------------------------------------------------
export var SectionMap = class SectionMap {
  constructor(lSections) {
    // --- lSections is a tree of section names
    debug("enter SectionMap()", lSections);
    this.lSections = lSections; // a tree of section names
    this.hSets = {};
    this.hSections = {};
    this.addSections(lSections);
    debug("return from SectionMap()", this.hSections);
  }

  // ..........................................................

    // --- TODO: Allow array to start with a set name ---
  addSections(desc) {
    var i, item, len;
    if (isString(desc)) {
      assert(nonEmpty(desc), "empty section name");
      assert(desc.match(/^[a-z][a-z0-9]*$/), `bad section name ${OL(desc)}`);
      assert(this.hSections[desc] === undef, `duplicate section ${OL(desc)}`);
      this.hSections[desc] = new Section();
    } else {
      assert(isArray(desc), `not an array or string ${OL(desc)}`);
      for (i = 0, len = desc.length; i < len; i++) {
        item = desc[i];
        this.addSections(item);
      }
    }
  }

  // ..........................................................
  // --- a generator - yield order is not guaranteed
  * allSections(desc) {
    var _, i, j, lNames, len, len1, name, ref, ref1, sect;
    debug("enter allSections()");
    if (desc === undef) {
      // --- We want to return all sections
      debug("yield all sections");
      ref = this.hSections;
      for (_ in ref) {
        sect = ref[_];
        yield sect;
      }
    } else if (isString(desc)) {
      if (isSectionName(desc)) {
        debug(`yield section ${OL(desc)}`);
        yield this.section(desc);
      } else if (isSetName(desc)) {
        debug(`expand set ${OL(desc)}`);
        debug('hSets', this.hSets);
        lNames = this.hSets[desc];
        assert(defined(lNames), `no set named ${OL(desc)}`);
        debug(`set ${desc}`, lNames);
        for (i = 0, len = lNames.length; i < len; i++) {
          name = lNames[i];
          debug(`yield section ${OL(desc)}`);
          yield this.section(name);
        }
      } else {
        croak(`bad name ${OL(desc)}`);
      }
    } else {
      assert(isArray(desc), "not an array");
      for (j = 0, len1 = desc.length; j < len1; j++) {
        name = desc[j];
        debug(`yield section ${OL(name)}`);
        assert(isString(name), `not a string ${OL(name)}`);
        if (isSectionName(name)) {
          yield this.section(name);
        } else if (isSetName(name)) {
          ref1 = this.hSets[name];
          for (_ in ref1) {
            sect = ref1[_];
            yield sect;
          }
        } else {
          croak(`bad name ${OL(name)}`);
        }
      }
    }
    debug("return from allSections()");
  }

  // ..........................................................
  addSet(name, lSections) {
    var i, len, secName;
    debug("enter addSet()", name, lSections);
    // --- check the name
    assert(isSetName(name), `not a valid set name ${OL(name)}`);
    // --- check lSections
    assert(isArray(lSections), "arg 2 not an array");
    for (i = 0, len = lSections.length; i < len; i++) {
      secName = lSections[i];
      assert(isNonEmptyString(secName), `not a non-empty string ${OL(secName)}`);
      assert(defined(this.hSections[secName]), `not a section name ${OL(secName)}`);
    }
    this.hSets[name] = lSections;
    debug('hSets', this.hSets);
    debug("return from addSet()");
  }

  // ..........................................................
  section(name) {
    var sect;
    sect = this.hSections[name];
    assert(defined(sect), `No section named ${OL(name)}`);
    return sect;
  }

  // ..........................................................
  firstSection(name) {
    var lSections;
    assert(isSetName(name), `bad set name ${OL(name)}`);
    lSections = this.hSets[name];
    assert(defined(lSections), `no such set ${OL(name)}`);
    assert(nonEmpty(lSections), `empty section ${OL(name)}`);
    return this.section(lSections[0]);
  }

  // ..........................................................
  lastSection(name) {
    var lSections;
    assert(isSetName(name), `bad set name ${OL(name)}`);
    lSections = this.hSets[name];
    assert(defined(lSections), `no such set ${OL(name)}`);
    assert(nonEmpty(lSections), `empty section ${OL(name)}`);
    return this.section(lSections[lSections.length - 1]);
  }

  // ..........................................................
  length(desc = undef) {
    var ref, result, sect;
    result = 0;
    ref = this.allSections(desc);
    for (sect of ref) {
      result += sect.length();
    }
    return result;
  }

  // ..........................................................
  isEmpty(desc = undef) {
    return this.length(desc) === 0;
  }

  // ..........................................................
  nonEmpty(desc = undef) {
    return this.length(desc) > 0;
  }

  // ..........................................................
  indent(desc = undef, level = 1) {
    var ref, sect;
    ref = this.allSections(desc);
    for (sect of ref) {
      sect.indent(level);
    }
  }

  // ..........................................................
  enclose(name, pre, post) {
    var sect;
    if (isSectionName(name)) {
      sect = this.section(name);
      if (sect.nonEmpty()) {
        sect.indent();
        sect.prepend(pre);
        sect.add(post);
      }
    } else if (isSetName(name)) {
      if (this.nonEmpty(name)) {
        this.indent(name);
        this.firstSection(name).prepend(pre);
        this.lastSection(name).add(post);
      }
    } else {
      croak(`Bad name param ${OL(name)}`);
    }
  }

  // ..........................................................
  getBlock() {
    var result;
    debug("enter getBlock()");
    this.lAllBlocks = [];
    debug('lSections', this.lSections);
    this.accumBlock(this.lSections);
    debug('lAllBlocks', this.lAllBlocks);
    result = arrayToBlock(this.lAllBlocks);
    debug("return from getBlock()", result);
    return result;
  }

  // ..........................................................
  accumBlock(tree) {
    var block, i, len, subtree;
    if (isString(tree)) {
      debug(`accumBlock ${OL(tree)}`);
      block = this.section(tree).getBlock();
      if (nonEmpty(block)) {
        this.lAllBlocks.push(block);
      }
    } else {
      assert(isArray(tree), "not an array");
      for (i = 0, len = tree.length; i < len; i++) {
        subtree = tree[i];
        this.accumBlock(subtree);
      }
    }
  }

};
