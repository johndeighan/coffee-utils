// Generated by CoffeeScript 2.7.0
  // indent.coffee
import {
  assert,
  croak
} from '@jdeighan/base-utils/exceptions';

import {
  undef,
  defined,
  notdefined,
  toArray,
  toBlock,
  OL,
  isInteger,
  isString,
  isArray,
  isEmpty,
  rtrim
} from '@jdeighan/base-utils';

// ---------------------------------------------------------------------------
export var getOneIndent = (str) => {
  var lMatches;
  if ((lMatches = str.match(/^\t+(?:\S|$)/))) {
    return "\t";
  } else if ((lMatches = str.match(/^(\x20+)(?:\S|$)/))) { // space char
    return lMatches[1];
  }
  assert(notdefined(str.match(/^\s/)), "Mixed indentation types");
  return undef;
};

// ---------------------------------------------------------------------------
export var splitPrefix = (line) => {
  var lMatches;
  assert(isString(line), `non-string ${OL(line)}`);
  line = rtrim(line);
  lMatches = line.match(/^(\s*)(.*)$/);
  return [lMatches[1], lMatches[2]];
};

// ---------------------------------------------------------------------------
//   splitLine - separate a line into [level, line]
export var splitLine = (line, oneIndent = undef) => {
  var prefix, str;
  [prefix, str] = splitPrefix(line);
  return [indentLevel(prefix, oneIndent), str];
};

// ---------------------------------------------------------------------------
//   indentation - return appropriate indentation string for given level
//   export only to allow unit testing
export var indentation = (level, oneIndent = "\t") => {
  assert(level >= 0, "indentation(): negative level");
  return oneIndent.repeat(level);
};

// ---------------------------------------------------------------------------
//   indentLevel - determine indent level of a string
//                 it's OK if the string is ONLY indentation
export var indentLevel = (line, oneIndent = undef) => {
  var ch, lMatches, len, level, prefix, prefixLen;
  assert(isString(line), "not a string");
  // --- This will always match, and it's greedy
  if (lMatches = line.match(/^\s*/)) {
    prefix = lMatches[0];
    prefixLen = prefix.length;
  }
  if (prefixLen === 0) {
    return 0;
  }
  if (defined(oneIndent)) {
    // --- prefix must be some multiple of oneIndent
    len = oneIndent.length;
    assert(prefixLen % len === 0, `prefix ${OL(prefix)} not a mult of ${OL(oneIndent)}`);
    level = prefixLen / len;
  } else {
    ch = prefix.substring(0, 1);
    if (ch === "\t") {
      oneIndent = "\t";
      level = prefixLen;
    } else if (ch === ' ') {
      oneIndent = ' '.repeat(prefixLen);
      level = 1;
    } else {
      croak(`Bad Indentation in ${OL(line)}`);
    }
  }
  assert(prefix === oneIndent.repeat(level), `prefix ${OL(prefix)} not a mult of ${OL(oneIndent)}`);
  return level;
};

// ---------------------------------------------------------------------------
//   isUndented - true iff indentLevel(line) == 0
export var isUndented = (line) => {
  assert(isString(line), `non-string ${OL(line)}`);
  return notdefined(line.match(/^\s/));
};

// ---------------------------------------------------------------------------
//   indented - add indentation to each string in a block or array
//            - returns the same type as input, i.e. array or string
export var indented = (input, level = 1, oneIndent = "\t") => {
  var i, lLines, len1, line, ref, toAdd;
  // --- level can be a string, in which case it is
  //     pre-pended to each line of input
  if (isString(level)) {
    if (level === '') {
      return input;
    }
    toAdd = level;
  } else if (isInteger(level)) {
    if (level === 0) {
      return input;
    }
    assert(level > 0, `Invalid level ${OL(level)}`);
    toAdd = indentation(level, oneIndent);
  } else {
    croak(`Invalid level ${OL(level)}`);
  }
  // --- NOTE: toArray(input) just returns input if it's an array
  //           else it splits the string into an array of lines
  lLines = [];
  ref = toArray(input);
  for (i = 0, len1 = ref.length; i < len1; i++) {
    line = ref[i];
    if (isEmpty(line)) {
      lLines.push('');
    } else {
      lLines.push(`${toAdd}${line}`);
    }
  }
  if (isArray(input)) {
    return lLines;
  } else if (isString(input)) {
    return toBlock(lLines);
  }
  return croak(`Invalid input; ${OL(input)}`);
};

// ---------------------------------------------------------------------------
//   undented - string with 1st line indentation removed for each line
//            - ignore leading empty lines
//            - unless level is set, in which case exactly that
//              indentation is removed
//            - returns same type as text, i.e. either string or array
export var undented = (input, level = undef, oneIndent = "\t") => {
  var i, lLines, lMatches, lNewLines, len1, line, nToRemove, toRemove;
  if (defined(level) && (level === 0)) {
    return input;
  }
  // --- Remove any leading blank lines, set lLines
  if (isString(input)) {
    if (lMatches = input.match(/^[\r\n]+(.*)$/s)) {
      input = lMatches[1];
    }
    lLines = toArray(input);
  } else if (isArray(input)) {
    lLines = input;
    while ((lLines.length > 0) && isEmpty(lLines[0])) {
      lLines.shift();
    }
  } else {
    croak("input not a string or array");
  }
  if (lLines.length === 0) {
    if (isString(input)) {
      return '';
    } else {
      return [];
    }
  }
  // --- determine what to remove from beginning of each line
  if (defined(level)) {
    assert(isInteger(level), "level must be an integer");
    toRemove = indentation(level, oneIndent);
  } else {
    lMatches = lLines[0].match(/^\s*/);
    toRemove = lMatches[0];
  }
  nToRemove = indentLevel(toRemove);
  lNewLines = [];
  for (i = 0, len1 = lLines.length; i < len1; i++) {
    line = lLines[i];
    if (isEmpty(line)) {
      lNewLines.push('');
    } else {
      if (line.indexOf(toRemove) !== 0) {
        throw new Error(`remove ${OL(toRemove)} from ${OL(line)}`);
      }
      lNewLines.push(line.substr(nToRemove));
    }
  }
  if (isString(input)) {
    return toBlock(lNewLines);
  } else {
    return lNewLines;
  }
};

// ---------------------------------------------------------------------------
//    enclose - indent text, surround with pre and post
export var enclose = (text, pre, post, oneIndent = "\t") => {
  return toBlock([pre, indented(text, 1, oneIndent), post]);
};
