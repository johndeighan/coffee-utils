// Generated by CoffeeScript 2.7.0
  // debug_utils.coffee
var debugDebug, doDebugDebug, lFuncList, lFunctions, reMethod, strFuncList,
  indexOf = [].indexOf;

import {
  assert,
  undef,
  error,
  croak,
  warn,
  defined,
  isString,
  isFunction,
  isBoolean,
  OL,
  escapeStr,
  isNumber,
  isArray,
  words,
  pass
} from '@jdeighan/coffee-utils';

import {
  blockToArray
} from '@jdeighan/coffee-utils/block';

import {
  untabify
} from '@jdeighan/coffee-utils/indent';

import {
  slurp
} from '@jdeighan/coffee-utils/fs';

import {
  CallStack
} from '@jdeighan/coffee-utils/stack';

import {
  getPrefix,
  addArrow,
  removeLastVbar
} from '@jdeighan/coffee-utils/arrow';

import {
  log,
  logItem,
  LOG,
  shortEnough,
  dashes
} from '@jdeighan/coffee-utils/log';

// --- set in resetDebugging() and setDebugging()
export var callStack = new CallStack();

export var shouldLog = function() {
  return undef;
};

lFuncList = [];

strFuncList = undef; // original string


// --- internal debugging
doDebugDebug = false;

lFunctions = undef; // --- only used when doDebugDebug is true


// ---------------------------------------------------------------------------
export var dumpCallStack = function() {
  LOG(callStack.dump());
};

// ---------------------------------------------------------------------------
export var setDebugDebugging = function(value = true) {
  // --- value can be a boolean or string of words
  if (isBoolean(value)) {
    doDebugDebug = value;
  } else if (isString(value)) {
    doDebugDebug = true;
    lFunctions = words(value);
  } else {
    croak(`Bad value: ${OL(value)}`);
  }
};

// ---------------------------------------------------------------------------
debugDebug = function(label, ...lObjects) {
  var doLog, dolog, funcName, nObjects, type;
  if (!doDebugDebug) {
    return;
  }
  // --- At this point, doDebugDebug is true
  doDebugDebug = false; // temp - reset before returning
  assert(isString(label), `1st arg ${OL(label)} should be a string`);
  nObjects = lObjects.length;
  [type, funcName] = getType(label, nObjects);
  switch (type) {
    case 'enter':
      assert(defined(funcName), "type enter, funcName = undef");
      callStack.enter(funcName, lObjects);
      doLog = (lFunctions === undef) || (indexOf.call(lFunctions, funcName) >= 0);
      break;
    case 'return':
      assert(defined(funcName), "type return, funcName = undef");
      doLog = (lFunctions === undef) || (indexOf.call(lFunctions, funcName) >= 0);
      break;
    case 'string':
      assert(funcName === undef, "type string, funcName defined");
      assert(nObjects === 0, `Objects not allowed for ${OL(type)}`);
      doLog = true;
      break;
    case 'objects':
      assert(funcName === undef, "type objects, funcName defined");
      assert(nObjects > 0, `Objects required for ${OL(type)}`);
      dolog = true;
  }
  if (doLog) {
    doTheLogging(type, label, lObjects);
  }
  if ((type === 'enter') && doLog) {
    callStack.logCurFunc(funcName);
  } else if (type === 'return') {
    callStack.returnFrom(funcName);
  }
  doDebugDebug = true;
};

// ---------------------------------------------------------------------------
export var debug = function(label, ...lObjects) {
  var doLog, funcName, nObjects, type;
  assert(isString(label), `1st arg ${OL(label)} should be a string`);
  // --- If label is "enter <funcname>, we need to put that on the stack
  //     BEFORE we do any internal logging
  nObjects = lObjects.length;
  [type, funcName] = getType(label, nObjects);
  if (type === 'enter') {
    callStack.enter(funcName, lObjects);
  }
  debugDebug(`enter debug(${OL(label)})`, ...lObjects);
  debugDebug(`type = ${OL(type)}`);
  debugDebug(`funcName = ${OL(funcName)}`);
  // --- function shouldLog() returns the (possibly modified) label
  //     if we should log this, else it returns undef
  switch (type) {
    case 'enter':
      label = shouldLog(label, type, funcName, callStack);
      break;
    case 'return':
      label = shouldLog(label, type, funcName, callStack);
      break;
    case 'string':
      label = shouldLog(label, type, undef, callStack);
      assert(nObjects === 0, `Objects not allowed for ${OL(type)}`);
      break;
    case 'objects':
      label = shouldLog(label, type, undef, callStack);
      assert(nObjects > 0, `Objects required for ${OL(type)}`);
  }
  assert((label === undef) || isString(label), `label not a string: ${OL(label)}`);
  doLog = defined(label);
  debugDebug(`doLog = ${OL(doLog)}`);
  debugDebug(`${nObjects} objects`);
  if (doLog) {
    doTheLogging(type, label, lObjects);
  }
  if ((type === 'enter') && doLog && (label.indexOf('call') === -1)) {
    callStack.logCurFunc(funcName);
  }
  // --- This must be called BEFORE we return from funcName
  debugDebug("return from debug()");
  if (type === 'return') {
    callStack.returnFrom(funcName);
  }
  return true; // allow use in boolean expressions
};


// ---------------------------------------------------------------------------
export var doTheLogging = function(type, label, lObjects) {
  var i, itemPrefix, j, k, l, len, len1, len2, level, obj, prefix, sep;
  level = callStack.getLevel();
  prefix = getPrefix(level);
  itemPrefix = removeLastVbar(prefix);
  sep = dashes(itemPrefix, 40);
  assert(isString(sep), "sep is not a string");
  debugDebug("callStack", callStack);
  debugDebug(`level = ${OL(level)}`);
  debugDebug(`prefix = ${OL(prefix)}`);
  debugDebug(`itemPrefix = ${OL(itemPrefix)}`);
  debugDebug(`sep = ${OL(sep)}`);
  switch (type) {
    case 'enter':
      log(label, {prefix});
      for (i = j = 0, len = lObjects.length; j < len; i = ++j) {
        obj = lObjects[i];
        if (i > 0) {
          log(sep);
        }
        logItem(undef, obj, {itemPrefix});
      }
      break;
    case 'return':
      log(label, {
        prefix: addArrow(prefix)
      });
      for (i = k = 0, len1 = lObjects.length; k < len1; i = ++k) {
        obj = lObjects[i];
        if (i > 0) {
          log(sep);
        }
        logItem(undef, obj, {itemPrefix});
      }
      break;
    case 'string':
      log(label, {prefix});
      break;
    case 'objects':
      if ((lObjects.length === 1) && shortEnough(label, lObjects[0])) {
        logItem(label, lObjects[0], {prefix});
      } else {
        if (label.indexOf(':') !== label.length - 1) {
          label += ':';
        }
        log(label, {prefix});
        for (l = 0, len2 = lObjects.length; l < len2; l++) {
          obj = lObjects[l];
          logItem(undef, obj, {prefix});
        }
      }
  }
};

// ---------------------------------------------------------------------------
export var stdShouldLog = function(label, type, funcName, stack) {
  var prevLogged, result;
  // --- if type is 'enter', then funcName won't be on the stack yet
  //     returns the (possibly modified) label to log

  // --- If we're logging now,
  //     but we won't be logging when funcName is activated
  //     then change 'enter' to 'call'
  assert(isString(label), `label ${OL(label)} not a string`);
  assert(isString(type), `type ${OL(type)} not a string`);
  if ((type === 'enter') || (type === 'return')) {
    assert(isString(funcName), `func name ${OL(funcName)} not a string`);
  } else {
    assert(funcName === undef, `func name ${OL(funcName)} not undef`);
  }
  assert(stack instanceof CallStack, "not a call stack object");
  debugDebug(`enter stdShouldLog(${OL(label)}, ${OL(type)}, ${OL(funcName)}, stack)`);
  switch (type) {
    case 'enter':
      if (funcMatch()) {
        debugDebug(`return ${OL(label)} from stdShouldLog() - funcMatch`);
        return label;
      } else {
        // --- As a special case, if we enter a function where we will not
        //     be logging, but we were logging in the calling function,
        //     we'll log out the call itself
        prevLogged = stack.isLoggingPrev();
        if (prevLogged) {
          result = label.replace('enter', 'call');
          debugDebug(`return ${OL(result)} from stdShouldLog() - s/enter/call/`);
          return result;
        }
      }
      break;
    default:
      if (funcMatch()) {
        debugDebug(`return ${OL(label)} from stdShouldLog()`);
        return label;
      }
  }
  debugDebug("return undef from stdShouldLog()");
  return undef;
};

// ---------------------------------------------------------------------------
export var setDebugging = function(option) {
  callStack.reset();
  if (isBoolean(option)) {
    if (option) {
      shouldLog = function(label, type, funcName, stack) {
        return label;
      };
    } else {
      shouldLog = function(label, type, funcName, stack) {
        return undef;
      };
    }
  } else if (isString(option)) {
    lFuncList = getFuncList(option);
    shouldLog = stdShouldLog;
  } else if (isFunction(option)) {
    shouldLog = option;
  } else {
    croak(`bad parameter ${OL(option)}`);
  }
};

// ---------------------------------------------------------------------------
// --- export only to allow unit tests
export var getFuncList = function(str) {
  var _, ident1, ident2, j, lMatches, len, plus, ref, word;
  strFuncList = str; // store original string for debugging
  lFuncList = [];
  ref = words(str);
  for (j = 0, len = ref.length; j < len; j++) {
    word = ref[j];
    if (lMatches = word.match(/^([A-Za-z_][A-Za-z0-9_]*)(?:\.([A-Za-z_][A-Za-z0-9_]*))?(\+)?$/)) {
      [_, ident1, ident2, plus] = lMatches;
      if (ident2) {
        lFuncList.push({
          name: ident2,
          object: ident1,
          plus: plus === '+'
        });
      } else {
        lFuncList.push({
          name: ident1,
          plus: plus === '+'
        });
      }
    } else {
      croak(`Bad word in func list: ${OL(word)}`);
    }
  }
  return lFuncList;
};

// ---------------------------------------------------------------------------
// --- export only to allow unit tests
export var funcMatch = function() {
  var curFunc, h, j, len, name, object, plus;
  assert(isArray(lFuncList), `not an array ${OL(lFuncList)}`);
  debugDebug("enter funcMatch()");
  curFunc = callStack.curFunc();
  debugDebug(`curFunc = ${OL(curFunc)}`);
  debugDebug(`lFuncList = ${strFuncList}`);
  for (j = 0, len = lFuncList.length; j < len; j++) {
    h = lFuncList[j];
    ({name, object, plus} = h);
    if (name === curFunc) {
      debugDebug("return from funcMatch() - curFunc in lFuncList");
      return true;
    }
    if (plus && callStack.isActive(name)) {
      debugDebug(`return from funcMatch() - func ${OL(name)} is active`);
      return true;
    }
  }
  debugDebug("return from funcMatch() - no match");
  return false;
};

// ---------------------------------------------------------------------------
// --- type is one of: 'enter', 'return', 'string', 'object'
export var getType = function(str, nObjects) {
  var lMatches;
  if (lMatches = str.match(/^\s*enter\s+([A-Za-z_][A-Za-z0-9_\.]*)/)) {
    // --- We are entering function curFunc
    return ['enter', lMatches[1]];
  } else if (lMatches = str.match(/^\s*return.+from\s+([A-Za-z_][A-Za-z0-9_\.]*)/)) {
    return ['return', lMatches[1]];
  } else if (nObjects > 0) {
    return ['objects', undef];
  } else {
    return ['string', undef];
  }
};

// ---------------------------------------------------------------------------
reMethod = /^([A-Za-z_][A-Za-z0-9_]*)\.([A-Za-z_][A-Za-z0-9_]*)$/;

// ---------------------------------------------------------------------------
