// Generated by CoffeeScript 2.7.0
  // debug_utils.coffee
var callStack, doDebugDebug, lFunctions, logif, reMethod,
  indexOf = [].indexOf;

import {
  assert,
  undef,
  error,
  croak,
  warn,
  defined,
  isString,
  isFunction,
  isBoolean,
  OL,
  escapeStr,
  isNumber,
  isArray,
  words,
  pass
} from '@jdeighan/coffee-utils';

import {
  blockToArray
} from '@jdeighan/coffee-utils/block';

import {
  untabify
} from '@jdeighan/coffee-utils/indent';

import {
  slurp
} from '@jdeighan/coffee-utils/fs';

import {
  CallStack
} from '@jdeighan/coffee-utils/stack';

import {
  getPrefix,
  addArrow,
  removeLastVbar
} from '@jdeighan/coffee-utils/arrow';

import {
  log,
  logItem,
  LOG,
  shortEnough,
  dashes
} from '@jdeighan/coffee-utils/log';

callStack = new CallStack();

// --- set in resetDebugging() and setDebugging()
export var shouldLog = function() {
  return undef;
};

export var lFuncList = [];

// --- internal debugging
doDebugDebug = false;

lFunctions = undef; // --- only used when doDebugDebug is true


// ---------------------------------------------------------------------------
export var setDebugDebugging = function(value = true) {
  // --- value can be a boolean or string of words
  if (isBoolean(value)) {
    doDebugDebug = value;
  } else if (isString(value)) {
    doDebugDebug = true;
    lFunctions = words(value);
  } else {
    croak(`Bad value: ${OL(value)}`);
  }
};

// ---------------------------------------------------------------------------
logif = function(label, ...lObjects) {
  var funcName, itemPrefix, level, nObjects, prefix, sep, type;
  if (!doDebugDebug) {
    return;
  }
  assert(isString(label), `1st arg ${OL(label)} should be a string`);
  nObjects = lObjects.length;
  [type, funcName] = getType(label, nObjects);
  level = callStack.getLevel();
  prefix = getPrefix(level);
  itemPrefix = removeLastVbar(prefix);
  sep = dashes(itemPrefix, 40);
  if (type === 'enter') {
    if (defined(lFunctions) && (indexOf.call(lFunctions, funcName) < 0)) {
      return;
    }
    callStack.enter(funcName);
  } else if (type === 'return') {
    if (defined(lFunctions) && (indexOf.call(lFunctions, funcName) < 0)) {
      return;
    }
  }
  doTheLogging(type, label, lObjects);
  if (type === 'return') {
    callStack.returnFrom(funcName);
  }
};

// ---------------------------------------------------------------------------
export var debug = function(label, ...lObjects) {
  var doLog, funcName, nObjects, type;
  logif(`enter debug(${OL(label)})`, ...lObjects);
  assert(isString(label), `1st arg ${OL(label)} should be a string`);
  // --- We want to allow objects to be undef. Therefore, we need to
  //     distinguish between 1 arg sent vs. 2 or more args sent
  nObjects = lObjects.length;
  // --- funcName is only set for types 'enter' and 'return'
  [type, funcName] = getType(label, nObjects);
  logif(`type = ${OL(type)}`);
  logif(`funcName = ${OL(funcName)}`);
  // --- function shouldLog() returns the (possibly modified) label
  //     if we should log this, else it returns undef
  switch (type) {
    case 'enter':
      callStack.enter(funcName);
      label = shouldLog(label, type, funcName, callStack);
      break;
    case 'return':
      label = shouldLog(label, type, funcName, callStack);
      break;
    case 'string':
      label = shouldLog(label, type, undef, callStack);
      assert(nObjects === 0, `Objects not allowed for ${OL(type)}`);
      break;
    case 'objects':
      label = shouldLog(label, type, undef, callStack);
      assert(nObjects > 0, `Objects required for ${OL(type)}`);
  }
  assert((label === undef) || isString(label), `label not a string: ${OL(label)}`);
  doLog = defined(label);
  logif(`doLog = ${OL(doLog)}`);
  logif(`${nObjects} objects`);
  if (doLog) {
    doTheLogging(type, label, lObjects);
  }
  if ((type === 'enter') && doLog && (label.indexOf('call') === -1)) {
    callStack.logCurFunc();
  } else if (type === 'return') {
    callStack.returnFrom(funcName);
  }
  logif("return from debug()");
  return true; // allow use in boolean expressions
};


// ---------------------------------------------------------------------------
export var doTheLogging = function(type, label, lObjects) {
  var i, itemPrefix, j, k, l, len, len1, len2, level, obj, prefix, sep;
  level = callStack.getLevel();
  prefix = getPrefix(level);
  itemPrefix = removeLastVbar(prefix);
  sep = dashes(itemPrefix, 40);
  assert(isString(sep), "sep is not a string");
  logif("callStack", callStack);
  logif(`level = ${OL(level)}`);
  logif(`prefix = ${OL(prefix)}`);
  logif(`itemPrefix = ${OL(itemPrefix)}`);
  logif(`sep = ${OL(sep)}`);
  switch (type) {
    case 'enter':
      log(label, {prefix});
      for (i = j = 0, len = lObjects.length; j < len; i = ++j) {
        obj = lObjects[i];
        if (i > 0) {
          log(sep);
        }
        logItem(undef, obj, {itemPrefix});
      }
      break;
    case 'return':
      log(label, {
        prefix: addArrow(prefix)
      });
      for (i = k = 0, len1 = lObjects.length; k < len1; i = ++k) {
        obj = lObjects[i];
        if (i > 0) {
          log(sep);
        }
        logItem(undef, obj, {itemPrefix});
      }
      break;
    case 'string':
      log(label, {prefix});
      break;
    case 'objects':
      if ((lObjects.length === 1) && shortEnough(label, lObjects[0])) {
        logItem(label, lObjects[0], {prefix});
      } else {
        if (label.indexOf(':') !== label.length - 1) {
          label += ':';
        }
        log(label, {prefix});
        for (l = 0, len2 = lObjects.length; l < len2; l++) {
          obj = lObjects[l];
          logItem(undef, obj, {prefix});
        }
      }
  }
};

// ---------------------------------------------------------------------------
export var stdShouldLog = function(label, type, funcName, stack) {
  var prevLogged;
  // --- if type is 'enter', then funcName won't be on the stack yet
  //     returns the (possibly modified) label to log

  // --- If we're logging now,
  //     but we won't be logging when funcName is activated
  //     then change 'enter' to 'call'
  assert(isString(label), `label ${OL(label)} not a string`);
  assert(isString(type), `type ${OL(type)} not a string`);
  if ((type === 'enter') || (type === 'return')) {
    assert(isString(funcName), `func name ${OL(funcName)} not a string`);
  } else {
    assert(funcName === undef, `func name ${OL(funcName)} not undef`);
  }
  assert(stack instanceof CallStack, "not a call stack object");
  logif(`stdShouldLog(${OL(label)}, ${OL(type)}, ${OL(funcName)}, stack)`);
  logif("stack", stack);
  logif("lFuncList", lFuncList);
  switch (type) {
    case 'enter':
      if (funcMatch(stack, lFuncList)) {
        return label;
      } else {
        // --- As a special case, if we enter a function where we will not
        //     be logging, but we were logging in the calling function,
        //     we'll log out the call itself
        prevLogged = stack.isLoggingPrev();
        if (prevLogged) {
          return label.replace('enter', 'call');
        }
      }
      break;
    default:
      if (funcMatch(stack, lFuncList)) {
        return label;
      }
  }
  return undef;
};

// ---------------------------------------------------------------------------
export var setDebugging = function(option) {
  callStack.reset();
  if (isBoolean(option)) {
    if (option) {
      shouldLog = function(label, type, funcName, stack) {
        return label;
      };
    } else {
      shouldLog = function(label, type, funcName, stack) {
        return undef;
      };
    }
  } else if (isString(option)) {
    lFuncList = getFuncList(option);
    shouldLog = stdShouldLog;
  } else if (isFunction(option)) {
    shouldLog = option;
  } else {
    croak(`bad parameter ${OL(option)}`);
  }
};

// ---------------------------------------------------------------------------
// --- export only to allow unit tests
export var getFuncList = function(str) {
  var _, ident1, ident2, j, lMatches, len, plus, ref, word;
  lFuncList = [];
  ref = words(str);
  for (j = 0, len = ref.length; j < len; j++) {
    word = ref[j];
    if (lMatches = word.match(/^([A-Za-z_][A-Za-z0-9_]*)(?:\.([A-Za-z_][A-Za-z0-9_]*))?(\+)?$/)) {
      [_, ident1, ident2, plus] = lMatches;
      if (ident2) {
        lFuncList.push({
          name: ident2,
          object: ident1,
          plus: plus === '+'
        });
      } else {
        lFuncList.push({
          name: ident1,
          plus: plus === '+'
        });
      }
    } else {
      croak(`Bad word in func list: ${OL(word)}`);
    }
  }
  return lFuncList;
};

// ---------------------------------------------------------------------------
// --- export only to allow unit tests
export var funcMatch = function(stack, lFuncList) {
  var curFunc, h, j, len, name, object, plus;
  assert(isArray(lFuncList), `not an array ${OL(lFuncList)}`);
  curFunc = stack.curFunc();
  logif(`funcMatch(): curFunc = ${OL(curFunc)}`);
  logif(stack.dump('   '));
  logif('lFuncList', lFuncList);
  for (j = 0, len = lFuncList.length; j < len; j++) {
    h = lFuncList[j];
    ({name, object, plus} = h);
    if (name === curFunc) {
      logif("   curFunc in lFuncList - match successful");
      return true;
    }
    if (plus && stack.isActive(name)) {
      logif(`   func ${OL(name)} is active - match successful`);
      return true;
    }
  }
  logif("   - no match");
  return false;
};

// ---------------------------------------------------------------------------
// --- type is one of: 'enter', 'return', 'string', 'object'
export var getType = function(str, nObjects) {
  var lMatches;
  if (lMatches = str.match(/^\s*enter\s+([A-Za-z_][A-Za-z0-9_\.]*)/)) {
    // --- We are entering function curFunc
    return ['enter', lMatches[1]];
  } else if (lMatches = str.match(/^\s*return.+from\s+([A-Za-z_][A-Za-z0-9_\.]*)/)) {
    return ['return', lMatches[1]];
  } else if (nObjects > 0) {
    return ['objects', undef];
  } else {
    return ['string', undef];
  }
};

// ---------------------------------------------------------------------------
reMethod = /^([A-Za-z_][A-Za-z0-9_]*)\.([A-Za-z_][A-Za-z0-9_]*)$/;

// ---------------------------------------------------------------------------
