// Generated by CoffeeScript 2.5.1
// debug_utils.coffee
var arrow, arrowhead, corner, debugLevel, getPrefix, hbar, ifMatches, indent, lDebugFuncs, lDebugStack, vbar;

import {
  strict as assert
} from 'assert';

import {
  undef,
  error,
  croak,
  warn,
  words,
  isString,
  isFunction,
  stringToArray,
  oneline,
  escapeStr,
  isNumber,
  isArray
} from '@jdeighan/coffee-utils';

import {
  log
} from '@jdeighan/coffee-utils/log';

vbar = '│'; // unicode 2502

hbar = '─'; // unicode 2500

corner = '└'; // unicode 2514

arrowhead = '>';

indent = vbar + '   ';

arrow = corner + hbar + arrowhead + ' ';

debugLevel = 0; // controls amount of indentation - we ensure it's never < 0


// --- items on lDebugStack are booleans
lDebugStack = [];

export var debugging = false;

ifMatches = void 0;

// --- turn debugging on when in one of these functions
//     when returning from one of these functions, restore previous setting
lDebugFuncs = void 0;

// ---------------------------------------------------------------------------
export var debugIfLineMatches = function(regexp = undef) {
  ifMatches = regexp;
};

// ---------------------------------------------------------------------------
export var setDebugging = function(x) {
  if (x === true) {
    // --- save current setting
    lDebugStack.push(debugging);
    debugging = true;
  } else if (x === false) {
    assert(lDebugStack.length > 0, "mismatched setDebugging() calls");
    debugging = lDebugStack.pop();
  } else if (isString(x)) {
    lDebugFuncs = words(x);
  } else if (isArray(x)) {
    lDebugFuncs = x;
  } else {
    croak(`setDebugging(): bad parameter ${oneline(x)}`);
  }
};

// ---------------------------------------------------------------------------
getPrefix = function(level) {
  if (level < 0) {
    warn("You have mismatched debug 'enter'/'return' somewhere!");
    return '';
  }
  return '   '.repeat(level);
};

// ---------------------------------------------------------------------------
export var debug = function(...lArgs) {
  var curFunction, entering, exiting, item, lMatches, nArgs, prefix, str;
  nArgs = lArgs.length;
  assert((nArgs >= 1) && (nArgs <= 2), `debug(); Bad # args ${nArgs}`);
  str = lArgs[0];
  if (nArgs === 2) {
    item = lArgs[1];
  }
  // --- str must always be a string
  //     if 2 args, then str is meant to be a label for the item
  if (!debugging && (lDebugFuncs == null)) {
    return;
  }
  assert(isString(str), `debug(): 1st arg ${oneline(str)} should be a string`);
  // --- determine if we're entering or returning from a function
  entering = exiting = false;
  curFunction = undef;
  if ((lMatches = str.match(/^\s*enter\s+([A-Za-z_][A-Za-z0-9_]*)/))) {
    entering = true;
    curFunction = lMatches[1];
  } else if ((lMatches = str.match(/^\s*return.*from\s+([A-Za-z_][A-Za-z0-9_]*)/))) {
    exiting = true;
    curFunction = lMatches[1];
  }
  if (curFunction && lDebugFuncs && lDebugFuncs.includes(curFunction)) {
    if (entering) {
      setDebugging(true);
    }
    if (exiting) {
      setDebugging(false);
    }
  }
  if (debugging && ((ifMatches == null) || str.match(ifMatches))) {
    // --- set the prefix, i.e. indentation to use
    if (exiting) {
      if (debugLevel === 0) {
        prefix = arrow;
      } else {
        prefix = indent.repeat(debugLevel - 1) + arrow;
      }
    } else {
      prefix = indent.repeat(debugLevel);
    }
    log(str, item, prefix);
  }
  if (entering) {
    debugLevel += 1;
  }
  if (exiting && (debugLevel > 0)) {
    debugLevel -= 1;
  }
};
