// Generated by CoffeeScript 2.5.1
// debug_utils.coffee
var arrow, arrowhead, corner, debugLevel, getPrefix, hbar, ifMatches, indent, lDebugFuncs, lDebugStack, reMethod, restoreDebugEnv, saveDebugEnv, stripArrow, vbar;

import {
  strict as assert
} from 'assert';

import {
  undef,
  error,
  croak,
  warn,
  words,
  isString,
  isFunction,
  stringToArray,
  oneline,
  escapeStr,
  isNumber,
  isArray
} from '@jdeighan/coffee-utils';

import {
  log
} from '@jdeighan/coffee-utils/log';

vbar = '│'; // unicode 2502

hbar = '─'; // unicode 2500

corner = '└'; // unicode 2514

arrowhead = '>';

indent = vbar + '   ';

arrow = corner + hbar + arrowhead + ' ';

debugLevel = 0; // controls amount of indentation - we ensure it's never < 0

lDebugStack = [];

// --- These are saved/restored in lDebugStack
export var debugging = false;

ifMatches = undef;

lDebugFuncs = undef;

// ---------------------------------------------------------------------------
stripArrow = function(prefix) {
  return prefix.replace(arrow, '    ');
};

// ---------------------------------------------------------------------------
export var debugIfLineMatches = function(regexp = undef) {
  ifMatches = regexp;
};

// ---------------------------------------------------------------------------
saveDebugEnv = function() {
  lDebugStack.push({debugging, ifMatches, lDebugFuncs});
};

restoreDebugEnv = function() {
  var h;
  if (lDebugStack.length === 0) {
    debugging = false;
    ifMatches = undef;
    lDebugFuncs = undef;
  } else {
    h = lDebugStack.pop();
    ({debugging, ifMatches, lDebugFuncs} = h);
  }
};

// ---------------------------------------------------------------------------
export var setDebugging = function(x) {
  if (x === false) {
    restoreDebugEnv();
  } else {
    // --- save current setting
    saveDebugEnv();
    if (x === true) {
      debugging = true;
    } else if (isString(x)) {
      debugging = false;
      lDebugFuncs = words(x);
    } else {
      croak(`setDebugging(): bad parameter ${oneline(x)}`);
    }
  }
};

// ---------------------------------------------------------------------------
getPrefix = function(level) {
  if (level < 0) {
    warn("You have mismatched debug 'enter'/'return' somewhere!");
    return '';
  }
  return '   '.repeat(level);
};

// ---------------------------------------------------------------------------
export var resetDebugging = function() {
  debugging = false;
  debugLevel = 0;
  ifMatches = undef;
  lDebugFuncs = undef;
  lDebugStack = [];
};

// ---------------------------------------------------------------------------
export var debug = function(...lArgs) {
  var curFunc, entering, item, lMatches, nArgs, prefix, returning, str;
  // --- either 1 or 2 args
  if (!debugging && (lDebugFuncs == null)) {
    return;
  }
  nArgs = lArgs.length;
  assert((nArgs >= 1) && (nArgs <= 2), `debug(); Bad # args ${nArgs}`);
  str = lArgs[0];
  // --- str must always be a string
  //     if 2 args, then str is meant to be a label for the item
  assert(isString(str), `debug(): 1st arg ${oneline(str)} should be a string`);
  if (nArgs === 2) {
    item = lArgs[1];
  }
  // --- determine if we're entering or returning from a function
  entering = returning = false;
  curFunc = undef;
  if ((lMatches = str.match(/^\s*enter\s+([A-Za-z_][A-Za-z0-9_\.]*)/))) {
    entering = true;
    curFunc = lMatches[1];
  } else if ((lMatches = str.match(/^\s*return.*from\s+([A-Za-z_][A-Za-z0-9_\.]*)/))) {
    returning = true;
    curFunc = lMatches[1];
  }
  if (entering && lDebugFuncs && funcMatch(curFunc)) {
    setDebugging(true);
  }
  if (debugging && ((ifMatches == null) || str.match(ifMatches))) {
    // --- set the prefix, i.e. indentation to use
    if (returning) {
      if (debugLevel === 0) {
        prefix = arrow;
      } else {
        prefix = indent.repeat(debugLevel - 1) + arrow;
      }
    } else {
      prefix = indent.repeat(debugLevel);
    }
    if (nArgs === 1) {
      log(str, item, {prefix});
    } else {
      log(str, item, {
        prefix,
        logItem: true,
        itemPrefix: stripArrow(prefix)
      });
    }
  }
  if (returning && lDebugFuncs && funcMatch(curFunc)) {
    setDebugging(false); // revert to previous setting - might still be on
  }
  if (debugging) {
    if (entering) {
      debugLevel += 1;
    }
    if (returning && (debugLevel > 0)) {
      debugLevel -= 1;
    }
  }
};

// ---------------------------------------------------------------------------
reMethod = /^([A-Za-z_][A-Za-z0-9_]*)\.([A-Za-z_][A-Za-z0-9_]*)$/;

// ---------------------------------------------------------------------------
// --- export only to allow unit tests
export var funcMatch = function(curFunc) {
  var _, cls, lMatches, meth;
  if (lDebugFuncs.includes(curFunc)) {
    return true;
  } else if ((lMatches = curFunc.match(reMethod)) && ([_, cls, meth] = lMatches) && lDebugFuncs.includes(meth)) {
    return true;
  } else {
    return false;
  }
};
