// Generated by CoffeeScript 2.5.1
// debug_utils.coffee
var arrow, arrowhead, corner, debugLevel, hbar, ifMatches, indent, vbar;

import {
  undef,
  say,
  pass,
  error,
  isString,
  stringToArray,
  setLogger,
  setStringifier,
  escapeStr,
  stringifier,
  tamlStringifier
} from '@jdeighan/coffee-utils';

vbar = '│'; // unicode 2502

hbar = '─'; // unicode 2500

corner = '└'; // unicode 2514

arrowhead = '>';

indent = vbar + '   ';

arrow = corner + hbar + arrowhead + ' ';

debugLevel = 0; // controls amount of indentation


// --- Settings for variable debugging:
//        false   = debugging turned off
//        true    = debugging turned on
//        'force' = debugging always on, log calls to setDebugging()
export var debugging = false;

ifMatches = void 0;

// ---------------------------------------------------------------------------
export var setDebugging = function(flag, hOptions = {}) {
  var loggerFunc, regexp, stringifierFunc;
  // --- Valid options:
  //        loggerFunc - set the function for logging
  //        stringifierFunc - set the function for stringifying
  //        regexp - set ifMatches
  //        force - turn on permanently
  debugLevel = 0;
  if (debugging !== 'force') {
    if ((flag === true) || (flag === false) || (flag === 'force')) {
      debugging = flag;
    } else {
      error(`setDebugging(): Invalid value for flag: '${flag}'`);
    }
  }
  if (flag) {
    ({
      loggerFunc,
      stringifierFunc,
      ifMatches: regexp
    } = hOptions);
    if (loggerFunc) {
      setLogger(loggerFunc);
    } else {
      setLogger(console.log);
    }
    if (stringifierFunc) {
      setStringifier(stringifierFunc);
    } else {
      setStringifier(tamlStringifier);
    }
    if (regexp) {
      ifMatches = regexp;
    } else {
      ifMatches = undef;
    }
  } else {
    ifMatches = undef;
  }
};

// ---------------------------------------------------------------------------
export var debug = function(item, label = undef) {
  var entering, exiting, i, len, n, prefix, ref, str, toTest;
  if (!debugging) {
    return;
  }
  if (ifMatches != null) {
    toTest = label || item;
    if (isString(toTest) && !toTest.match(ifMatches)) {
      return;
    }
  }
  // --- if item is 'tree', just print label && increment debugLevel
  //     if item is 'untree', print nothing && decrement debugLevel
  if (item === 'tree') {
    say('   '.repeat(debugLevel) + label);
    debugLevel += 1;
    return;
  } else if (item === 'untree') {
    debugLevel -= 1;
    return;
  }
  // --- determine if we're entering or returning from a function
  entering = exiting = false;
  if (label) {
    if (!isString(label)) {
      error("debug(): label must be a string");
    }
    entering = label.indexOf('enter') === 0;
    exiting = label.indexOf('return') === 0;
  } else {
    if (!isString(item)) {
      error("debug(): single parameter must be a string");
    }
    entering = item.indexOf('enter') === 0;
    exiting = item.indexOf('return') === 0;
  }
  if (exiting) {
    n = debugLevel === 0 ? 0 : debugLevel - 1;
    prefix = indent.repeat(n) + arrow;
  } else {
    prefix = indent.repeat(debugLevel);
  }
  if (item == null) {
    if (label) {
      say(prefix + label + " undef");
    } else {
      say(prefix + " undef");
    }
  } else if (isString(item)) {
    if (label) {
      say(prefix + label + " '" + escapeStr(item) + "'");
    } else {
      say(prefix + escapeStr(item));
    }
  } else {
    if (label) {
      say(prefix + label);
    }
    ref = stringToArray(stringifier(item));
    for (i = 0, len = ref.length; i < len; i++) {
      str = ref[i];
      // --- We're exiting, but we want the normal prefix
      prefix = indent.repeat(debugLevel);
      say(prefix + '   ' + str.replace(/\t/g, '   '));
    }
  }
  if (entering) {
    debugLevel += 1;
  }
  if (exiting && (debugLevel > 0)) {
    debugLevel -= 1;
  }
};
