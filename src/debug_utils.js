// Generated by CoffeeScript 2.7.0
  // debug_utils.coffee
var callStack, doDebugDebug, reMethod, resetDebugging, shouldLog,
  indexOf = [].indexOf;

import {
  assert,
  undef,
  error,
  croak,
  warn,
  defined,
  isString,
  isFunction,
  isBoolean,
  sep_dash,
  OL,
  escapeStr,
  isNumber,
  isArray,
  words,
  pass
} from '@jdeighan/coffee-utils';

import {
  blockToArray
} from '@jdeighan/coffee-utils/block';

import {
  untabify
} from '@jdeighan/coffee-utils/indent';

import {
  slurp
} from '@jdeighan/coffee-utils/fs';

import {
  CallStack
} from '@jdeighan/coffee-utils/stack';

import {
  getPrefix,
  addArrow,
  removeLastVbar
} from '@jdeighan/coffee-utils/arrow';

import {
  log,
  logItem,
  LOG,
  shortEnough
} from '@jdeighan/coffee-utils/log';

callStack = new CallStack();

doDebugDebug = false;

shouldLog = undef; // set in resetDebugging() and setDebugging()


// ---------------------------------------------------------------------------
export var debugDebug = function(flag = true) {
  doDebugDebug = flag;
  if (doDebugDebug) {
    LOG(`doDebugDebug = ${flag}`);
  }
};

// ---------------------------------------------------------------------------
resetDebugging = function() {
  if (doDebugDebug) {
    LOG("resetDebugging()");
  }
  callStack.reset();
  shouldLog = function(type, str, stack) {
    return false;
  };
};

// ---------------------------------------------------------------------------
export var setDebugging = function(option) {
  resetDebugging();
  if (isBoolean(option)) {
    shouldLog = function(type, str, stack) {
      return option;
    };
  } else if (isString(option)) {
    shouldLog = function(type, str, stack) {
      var lFuncs;
      lFuncs = words(option);
      switch (type) {
        case 'enter':
          return funcMatch(stack, lFuncs, str);
        default:
          return funcMatch(stack, lFuncs);
      }
    };
    if (doDebugDebug) {
      LOG(`setDebugging FUNCS: ${option}`);
    }
  } else if (isFunction(option)) {
    shouldLog = option;
    if (doDebugDebug) {
      LOG("setDebugging to custom func");
    }
  } else {
    croak(`setDebugging(): bad parameter ${OL(option)}`);
  }
};

// ---------------------------------------------------------------------------
// --- export only to allow unit tests
export var funcMatch = function(stack, lFuncNames, enteringFunc = undef) {
  var _, cls, curFunc, lMatches, meth;
  if (defined(enteringFunc) && (indexOf.call(lFuncNames, enteringFunc) >= 0)) {
    return true;
  }
  curFunc = stack.curFunc();
  assert(isString(curFunc), `funcMatch(): not a string ${OL(curFunc)}`);
  assert(isArray(lFuncNames), `funcMatch(): bad array ${lFuncNames}`);
  if (lFuncNames.includes(curFunc)) {
    return true;
  } else if ((lMatches = curFunc.match(reMethod)) && ([_, cls, meth] = lMatches) && lFuncNames.includes(meth)) {
    return true;
  } else {
    return false;
  }
};

// ---------------------------------------------------------------------------
// --- type is one of: 'enter', 'return', 'string', 'object'
export var getType = function(str, nObjects) {
  var lMatches;
  if (lMatches = str.match(/^\s*enter\s+([A-Za-z_][A-Za-z0-9_\.]*)/)) {
    // --- We are entering function curFunc
    return ['enter', lMatches[1]];
  } else if (lMatches = str.match(/^\s*return.+from\s+([A-Za-z_][A-Za-z0-9_\.]*)/)) {
    return ['return', lMatches[1]];
  } else if (nObjects > 0) {
    return ['objects', undef];
  } else {
    return ['string', undef];
  }
};

// ---------------------------------------------------------------------------
export var debug = function(label, ...lObjects) {
  var doLog, funcName, i, j, k, l, len1, len2, len3, level, nObjects, obj, prefix, type;
  assert(isString(label), `1st arg ${OL(label)} should be a string`);
  // --- We want to allow objects to be undef. Therefore, we need to
  //     distinguish between 1 arg sent vs. 2 or more args sent
  nObjects = lObjects.length;
  // --- funcName is only set for types 'enter' and 'return'
  [type, funcName] = getType(label, nObjects);
  switch (type) {
    case 'enter':
      doLog = shouldLog(type, funcName, callStack);
      // --- If we won't be logging when funcName is activated
      //     then change 'enter' to 'call'
      callStack.enter(funcName); // add to call stack
      if (!shouldLog('string', 'abc', callStack)) {
        label = label.replace('enter', 'call');
      }
      callStack.returnFrom(funcName); // remove from call stack
      break;
    case 'return':
      doLog = shouldLog(type, funcName, callStack);
      break;
    case 'string':
      doLog = shouldLog(type, label, callStack);
      assert(nObjects === 0, `multiple objects only not allowed for ${OL(type)}`);
      break;
    case 'objects':
      doLog = shouldLog(type, label, callStack);
      assert(nObjects > 0, `multiple objects only not allowed for ${OL(type)}`);
  }
  if (doDebugDebug) {
    if (nObjects === 0) {
      LOG(`debug(${OL(label)}) - 1 arg`);
    } else {
      LOG(`debug(${OL(label)}), ${nObjects} args`);
    }
    LOG(`doLog = ${OL(doLog)}`);
    LOG(`type = ${OL(type)}`);
    LOG(`funcName = ${OL(funcName)}`);
  }
  if (doLog) {
    level = callStack.getLevel();
    prefix = getPrefix(level);
    if (doDebugDebug) {
      LOG("callStack", callStack);
      LOG(`level = ${OL(level)}`);
      LOG(`prefix = ${OL(prefix)}`);
    }
    switch (type) {
      case 'enter':
        log(label, {prefix});
        for (i = j = 0, len1 = lObjects.length; j < len1; i = ++j) {
          obj = lObjects[i];
          if (i > 0) {
            log(sep_dash, {
              prefix: removeLastVbar(prefix)
            });
          }
          logItem(undef, obj, {
            prefix: removeLastVbar(prefix)
          });
        }
        break;
      case 'return':
        log(label, {
          prefix: addArrow(prefix)
        });
        for (i = k = 0, len2 = lObjects.length; k < len2; i = ++k) {
          obj = lObjects[i];
          if (i > 0) {
            log(sep_dash, {
              prefix: removeLastVbar(prefix)
            });
          }
          logItem(undef, obj, {
            prefix: removeLastVbar(prefix)
          });
        }
        break;
      case 'string':
        log(label, {prefix});
        break;
      case 'objects':
        if ((nObjects === 1) && shortEnough(label, lObjects[0])) {
          logItem(label, lObjects[0], {prefix});
        } else {
          if (label.indexOf(':') !== label.length - 1) {
            label += ':';
          }
          log(label, {prefix});
          for (l = 0, len3 = lObjects.length; l < len3; l++) {
            obj = lObjects[l];
            logItem(undef, obj, {prefix});
          }
        }
    }
  }
  if (type === 'enter') {
    callStack.enter(funcName, doLog);
  } else if (type === 'return') {
    callStack.returnFrom(funcName);
  }
  return true; // allow use in boolean expressions
};


// ---------------------------------------------------------------------------
reMethod = /^([A-Za-z_][A-Za-z0-9_]*)\.([A-Za-z_][A-Za-z0-9_]*)$/;

// ---------------------------------------------------------------------------
export var checkTrace = function(block) {
  var funcName, j, lMatches, lStack, len, len1, line, ref;
  // --- export only to allow unit tests
  lStack = [];
  ref = blockToArray(block);
  for (j = 0, len1 = ref.length; j < len1; j++) {
    line = ref[j];
    if (lMatches = line.match(/enter\s+([A-Za-z_][A-Za-z0-9_\.]*)/)) {
      funcName = lMatches[1];
      lStack.push(funcName);
    } else if (lMatches = line.match(/return.*from\s+([A-Za-z_][A-Za-z0-9_\.]*)/)) {
      funcName = lMatches[1];
      len = lStack.length;
      if (len === 0) {
        log(`return from ${funcName} with empty stack`);
      } else if (lStack[len - 1] === funcName) {
        lStack.pop();
      } else if (lStack[len - 2] === funcName) {
        log(`missing return from ${lStack[len - 2]}`);
        lStack.pop();
        lStack.pop();
      } else {
        log(`return from ${funcName} - not found on stack`);
      }
    }
  }
};

// ---------------------------------------------------------------------------
resetDebugging();
