// Generated by CoffeeScript 2.7.0
// block.coffee
import fs from 'fs';

import readline from 'readline';

import {
  assert,
  croak
} from '@jdeighan/exceptions';

import {
  blockToArray,
  arrayToBlock
} from '@jdeighan/exceptions/utils';

import {
  undef,
  pass,
  defined,
  notdefined,
  isEmpty,
  isString,
  isArray,
  nonEmpty,
  isArrayOfStrings,
  rtrim,
  OL
} from '@jdeighan/coffee-utils';

export {
  blockToArray,
  arrayToBlock
};

// ---------------------------------------------------------------------------
//   toArray - split a block or array into lines w/o newlines
export var toArray = function(item, option = undef) {
  var i, j, lLines, lNewLines, len, len1, line, nonEmptyFound, ref, substr;
  // --- Valid options:
  //     'noEmptyLines'
  //     'noLeadingEmptyLines'
  if (isString(item)) {
    lLines = item.split(/\r?\n/);
  } else if (isArray(item)) {
    lLines = item;
  } else {
    croak("Not a string or array");
  }
  // --- We need to ensure that no strings contain newlines
  //     and possibly remove empty lines
  lNewLines = [];
  nonEmptyFound = false;
  for (i = 0, len = lLines.length; i < len; i++) {
    line = lLines[i];
    if (isEmpty(line)) {
      if ((option === 'noEmptyLines') || ((option === 'noLeadingEmptyLines') && !nonEmptyFound)) {
        pass;
      } else {
        lNewLines.push('');
      }
    } else if (line.indexOf("\n") > -1) {
      ref = toArray(line);
      for (j = 0, len1 = ref.length; j < len1; j++) {
        substr = ref[j];
        if (isEmpty(substr)) {
          if ((option === 'noEmptyLines') || ((option === 'noLeadingEmptyLines') && !nonEmptyFound)) {
            pass;
          } else {
            lNewLines.push('');
          }
        } else {
          nonEmptyFound = true;
          lNewLines.push(substr);
        }
      }
    } else {
      nonEmptyFound = true;
      lNewLines.push(line);
    }
  }
  return lNewLines;
};

// ---------------------------------------------------------------------------
//   toBlock - block may have trailing whitespace
//             but undef items are ignored
export var toBlock = function(lLines) {
  var i, lNewLines, len, line;
  if (notdefined(lLines)) {
    return undef;
  }
  assert(isArrayOfStrings(lLines), `lLines is not an array of strings: ${OL(lLines)}`);
  lNewLines = [];
  for (i = 0, len = lLines.length; i < len; i++) {
    line = lLines[i];
    if (defined(line)) {
      lNewLines.push(rtrim(line));
    }
  }
  return lNewLines.join("\n");
};

// ---------------------------------------------------------------------------
export var splitBlock = function(block) {
  var pos;
  assert(isString(block), "not a string");
  pos = block.indexOf('\n');
  if (pos === -1) {
    return [block, undef];
  } else {
    return [block.substring(0, pos), block.substring(pos + 1)];
  }
};

// ---------------------------------------------------------------------------
export var firstLine = function(block) {
  var pos;
  assert(isString(block), "not a string");
  pos = block.indexOf('\n');
  if (pos === -1) {
    return block;
  } else {
    return block.substring(0, pos);
  }
};

// ---------------------------------------------------------------------------
export var remainingLines = function(block) {
  var pos;
  assert(isString(block), "not a string");
  pos = block.indexOf('\n');
  if (pos === -1) {
    return undef;
  } else {
    return block.substring(pos + 1);
  }
};

// ---------------------------------------------------------------------------
//   normalizeBlock - remove blank lines, trim each line
//                  - collapse internal whitespace to ' '
export var normalizeBlock = function(content) {
  var lLines, line;
  if (typeof content !== 'string') {
    throw new Error("normalizeBlock(): not a string");
  }
  lLines = (function() {
    var i, len, ref, results;
    ref = blockToArray(content);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      line = ref[i];
      line = line.trim();
      results.push(line.replace(/\s+/g, ' '));
    }
    return results;
  })();
  lLines = lLines.filter(function(line) {
    return line !== '';
  });
  return lLines.join('\n');
};

// ---------------------------------------------------------------------------
// truncateBlock - limit block to a certain number of lines
export var truncateBlock = function(str, numLines) {
  var lLines;
  lLines = blockToArray(str);
  lLines.length = numLines;
  return arrayToBlock(lLines);
};

// ---------------------------------------------------------------------------
export var joinBlocks = function(...lBlocks) {
  var block, i, lNonEmptyBlocks, len, ref;
  lNonEmptyBlocks = [];
  ref = lBlocks.flat(999);
  for (i = 0, len = ref.length; i < len; i++) {
    block = ref[i];
    assert(isString(block), `joinBlocks(): ${block} is not a string`);
    if (nonEmpty(block)) {
      lNonEmptyBlocks.push(block);
    }
  }
  return lNonEmptyBlocks.join('\n');
};


export async function forEachLine(filepath, func) {

const fileStream = fs.createReadStream(filepath);
const rl = readline.createInterface({
	input: fileStream,
	crlfDelay: Infinity
	});

// Note: we use the crlfDelay option to recognize all instances of CR LF
// ('\r\n') in input.txt as a single line break.

var lineNum = 0
for await (const line of rl) {
	lineNum += 1
	// Each line will be successively available here as 'line'
	if (func(line, lineNum)) {
		rl.close();      // close if true return value
		return;
		}
	}
} // forEachLine()
// ---------------------------------------------------------------------------
;

// ---------------------------------------------------------------------------
export var forEachBlock = async function(filepath, func, regexp = /^-{16,}$/) {
  var callback, earlyExit, firstLineNum, lLines;
  lLines = [];
  firstLineNum = 1;
  earlyExit = false;
  callback = function(line, lineNum) {
    var result;
    if (line.match(regexp)) {
      if (result = func(lLines.join('\n'), firstLineNum, line)) {
        if (result === true) {
          earlyExit = true;
          return true;
        } else if (result != null) {
          croak(`forEachBlock() - callback returned '${result}'`);
        }
      }
      lLines = [];
      firstLineNum = lineNum + 1;
    } else {
      lLines.push(line);
    }
  };
  await forEachLine(filepath, callback);
  if (!earlyExit) {
    func(lLines.join('\n'), firstLineNum);
  }
};

// ---------------------------------------------------------------------------
export var forEachSetOfBlocks = async function(filepath, func, block_regexp = /^-{16,}$/, set_regexp = /^={16,}$/) {
  var callback, earlyExit, firstLineNum, lBlocks, lLines;
  lBlocks = [];
  lLines = [];
  firstLineNum = 1;
  earlyExit = false;
  callback = function(line, lineNum) {
    var result;
    if (line.match(set_regexp)) {
      lBlocks.push(lLines.join('\n'));
      lLines = [];
      if (result = func(lBlocks, firstLineNum, line)) {
        if (result === true) {
          earlyExit = true;
          return true;
        } else if (result != null) {
          croak(`forEachSetOfBlocks() - callback returned '${result}'`);
        }
      }
      lBlocks = [];
      firstLineNum = lineNum + 1;
    } else if (line.match(block_regexp)) {
      lBlocks.push(lLines.join('\n'));
      lLines = [];
    } else {
      lLines.push(line);
    }
  };
  await forEachLine(filepath, callback);
  if (!earlyExit) {
    lBlocks.push(lLines.join('\n'));
    func(lBlocks, firstLineNum);
  }
};
