// Generated by CoffeeScript 2.7.0
// call_stack.coffee
var doDebugStack;

import {
  undef,
  defined,
  croak,
  assert,
  OL,
  isBoolean,
  escapeStr,
  deepCopy
} from '@jdeighan/coffee-utils';

import {
  log,
  LOG
} from '@jdeighan/coffee-utils/log';

import {
  getPrefix
} from '@jdeighan/coffee-utils/arrow';

doDebugStack = false;

// ---------------------------------------------------------------------------
export var debugStack = function(flag = true) {
  doDebugStack = flag;
};

// ---------------------------------------------------------------------------
export var CallStack = class CallStack {
  constructor() {
    this.lStack = [];
    this.level = 0;
  }

  // ........................................................................
  reset() {
    if (doDebugStack) {
      LOG("RESET STACK");
    }
    this.lStack = [];
    this.level = 0;
  }

  // ........................................................................
  enter(funcName, lArgs = []) {
    var _, ident1, ident2, lMatches;
    // --- funcName might be <object>.<method>
    if (doDebugStack) {
      LOG(`[--> ENTER ${funcName}]`);
    }
    lMatches = funcName.match(/^([A-Za-z_][A-Za-z0-9_]*)(?:\.([A-Za-z_][A-Za-z0-9_]*))?$/);
    assert(defined(lMatches), `Bad funcName: ${OL(funcName)}`);
    [_, ident1, ident2] = lMatches;
    if (ident2) {
      this.lStack.push({
        fullName: funcName, //    "#{ident1}.#{ident2}"
        funcName: ident2,
        isLogged: false,
        lArgs: deepCopy(lArgs)
      });
    } else {
      this.lStack.push({
        fullName: funcName,
        funcName: ident1,
        isLogged: false,
        lArgs: deepCopy(lArgs)
      });
    }
  }

  // ........................................................................
  getLevel() {
    return this.level;
  }

  // ........................................................................
  isLogging() {
    if (this.lStack.length === 0) {
      return false;
    } else {
      return this.lStack[this.lStack.length - 1].isLogged;
    }
  }

  // ........................................................................
  isLoggingPrev() {
    if (this.lStack.length < 2) {
      return false;
    } else {
      return this.lStack[this.lStack.length - 2].isLogged;
    }
  }

  // ........................................................................
  logCurFunc(funcName) {
    var cur;
    // --- funcName must be  the current function
    //     and the isLogged flag must currently be false
    cur = this.lStack[this.lStack.length - 1];
    assert(cur.isLogged === false, "isLogged is already true");
    if (funcName !== cur.fullName) {
      LOG(`cur func ${cur.fullName} is not ${funcName}`);
      LOG(this.dump());
      croak("BAD");
    }
    cur.isLogged = true;
    this.level += 1;
  }

  // ........................................................................
  // --- if stack is empty, log the error, but continue
  returnFrom(fName) {
    var fullName, isLogged;
    if (doDebugStack) {
      LOG(`[<-- BACK ${fName}]`);
    }
    if (this.lStack.length === 0) {
      LOG(`ERROR: returnFrom('${fName}') but stack is empty`);
      return;
    }
    ({fullName, isLogged} = this.lStack.pop());
    if (isLogged && (this.level > 0)) {
      this.level -= 1;
    }
    // --- This should do nothing
    while ((fullName !== fName) && (this.lStack.length > 0)) {
      LOG(`[MISSING RETURN FROM ${fullName} (return from ${fName})]`);
      ({fullName, isLogged} = this.lStack.pop());
      if (isLogged && (this.level > 0)) {
        this.level -= 1;
      }
    }
    if (fullName !== fName) {
      this.dump();
      LOG(`BAD BAD BAD BAD returnFrom('${fName}')`);
    }
  }

  // ........................................................................
  curFunc() {
    if (this.lStack.length === 0) {
      return 'main';
    } else {
      return this.lStack[this.lStack.length - 1].funcName;
    }
  }

  // ........................................................................
  isActive(funcName) {
    var h, j, len, ref;
    ref = this.lStack;
    // --- funcName won't be <obj>.<method>
    //     but the stack might contain that form
    for (j = 0, len = ref.length; j < len; j++) {
      h = ref[j];
      if (h.funcName === funcName) {
        return true;
      }
    }
    return false;
  }

  // ........................................................................
  dump() {
    var i, item, j, lLines, len, ref;
    lLines = ["CALL STACK:"];
    if (this.lStack.length === 0) {
      lLines.push("   <EMPTY>");
    } else {
      ref = this.lStack;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        item = ref[i];
        lLines.push("   " + this.callStr(i, item));
      }
    }
    return lLines.join("\n");
  }

  // ........................................................................
  callStr(i, item) {
    var arg, j, len, ref, str, sym;
    sym = item.isLogged ? '*' : '';
    str = `${i}${sym}: ${item.fullName}`;
    ref = item.lArgs;
    for (j = 0, len = ref.length; j < len; j++) {
      arg = ref[j];
      str += ` ${OL(arg)}`;
    }
    return str;
  }

  // ........................................................................
  sdump(label = 'CALL STACK') {
    var item, j, lFuncNames, len, ref;
    lFuncNames = [];
    ref = this.lStack;
    for (j = 0, len = ref.length; j < len; j++) {
      item = ref[j];
      if (item.isLogged) {
        lFuncNames.push('*' + item.fullName);
      } else {
        lFuncNames.push(item.fullName);
      }
    }
    if (this.lStack.length === 0) {
      return `${label} <EMPTY>`;
    } else {
      return `${label} ${lFuncNames.join(' ')}`;
    }
  }

};
