// Generated by CoffeeScript 2.7.0
// call_stack.coffee
var doDebugStack;

import {
  undef,
  defined,
  croak,
  assert,
  isBoolean,
  escapeStr
} from '@jdeighan/coffee-utils';

import {
  log,
  LOG
} from '@jdeighan/coffee-utils/log';

import {
  getPrefix
} from '@jdeighan/coffee-utils/arrow';

doDebugStack = false;

// ---------------------------------------------------------------------------
export var debugStack = function(flag = true) {
  doDebugStack = flag;
};

// ---------------------------------------------------------------------------
export var CallStack = class CallStack {
  constructor() {
    this.lStack = [];
    this.level = 0;
  }

  // ........................................................................
  reset() {
    if (doDebugStack) {
      LOG("RESET STACK");
    }
    this.lStack = [];
    this.level = 0;
  }

  // ........................................................................
  enter(funcName, isLogged = false) {
    if (doDebugStack) {
      LOG(`[--> CALL ${funcName}]`);
    }
    this.lStack.push({funcName, isLogged});
    if (isLogged) {
      this.level += 1;
    }
  }

  // ........................................................................
  // --- if stack is empty, log the error, but continue
  returnFrom(fName) {
    var funcName, isLogged;
    if (doDebugStack) {
      LOG(`[<-- BACK ${fName}]`);
    }
    if (this.lStack.length === 0) {
      LOG(`ERROR: returnFrom('${funcName}') but stack is empty`);
      return;
    }
    ({funcName, isLogged} = this.lStack.pop());
    if (isLogged && (this.level > 0)) {
      this.level -= 1;
    }
    // --- This should do nothing
    while ((funcName !== fName) && (this.lStack.length > 0)) {
      LOG(`[MISSING RETURN FROM ${funcName} (return from ${fName})]`);
      ({funcName, isLogged} = this.lStack.pop());
      if (isLogged && (this.level > 0)) {
        this.level -= 1;
      }
    }
    if (funcName !== fName) {
      this.dump();
      LOG(`BAD BAD BAD BAD returnFrom('${fName}')`);
    }
  }

  // ........................................................................
  getLevel() {
    return this.level;
  }

  // ........................................................................
  curFunc() {
    if (this.lStack.length === 0) {
      return 'main';
    } else {
      return this.lStack[this.lStack.length - 1].funcName;
    }
  }

  // ........................................................................
  isActive(fName) {
    var h, j, len, ref;
    ref = this.lStack;
    for (j = 0, len = ref.length; j < len; j++) {
      h = ref[j];
      if (h.funcName === fName) {
        return true;
      }
    }
    return false;
  }

  // ........................................................................
  // ........................................................................
  dump(label = 'CALL STACK') {
    var i, item, j, len, ref;
    LOG(`${label}:`);
    if (this.lStack.length === 0) {
      LOG("   <EMPTY>");
    } else {
      ref = this.lStack;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        item = ref[i];
        LOG(`   ${i}: ${JSON.stringify(item)}`);
      }
    }
  }

};
