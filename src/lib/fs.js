// Generated by CoffeeScript 2.7.0
// fs.coffee
var fix, isHiddenDir, isSystemDir;

import os from 'os';

import pathlib from 'path';

import urllib from 'url';

import fs from 'fs';

import {
  readFile,
  writeFile,
  rm,
  rmdir
} from 'node:fs/promises';

import {
  execSync
} from 'node:child_process';

import {
  undef,
  pass,
  defined,
  notdefined,
  rtrim,
  isEmpty,
  nonEmpty,
  isString,
  isArray,
  isHash,
  isRegExp,
  isFunction,
  isBoolean,
  OL,
  toBlock,
  getOptions,
  isArrayOfStrings,
  deepCopy,
  runCmd
} from '@jdeighan/base-utils';

import {
  fileExt,
  mydir,
  mkpath,
  isFile,
  mkDir,
  rmDir,
  rmFile,
  forEachLineInFile,
  isDir,
  parsePath,
  barf,
  barfJSON,
  slurp,
  slurpJSON,
  withExt
} from '@jdeighan/base-utils/fs';

import {
  assert,
  croak
} from '@jdeighan/base-utils/exceptions';

import {
  LOG,
  LOGVALUE
} from '@jdeighan/base-utils/log';

import {
  dbg,
  dbgEnter,
  dbgReturn
} from '@jdeighan/base-utils/debug';

import {
  fromTAML
} from '@jdeighan/base-utils/taml';

export {
  fileExt,
  mydir,
  mkpath,
  isFile,
  mkDir,
  rmDir,
  rmFile,
  forEachLineInFile,
  isDir,
  parsePath,
  barf,
  barfJSON,
  slurp,
  slurpJSON,
  withExt
};

fix = true;

// ---------------------------------------------------------------------------
export var doFixOutput = (flag = true) => {
  fix = flag;
};

// --------------------------------------------------------------------------
export var fixOutput = (contents) => {
  if (fix && isString(contents)) {
    return rtrim(contents) + "\n";
  } else {
    return contents;
  }
};

// --------------------------------------------------------------------------
export var fixFile = async(filepath, func) => {
  var contents, output;
  contents = (await readFile(filepath, {
    encoding: 'utf8'
  }));
  output = func(contents); // returns modified contents
  output = fixOutput(output);
  await writeFile(filepath, output, {
    encoding: 'utf8'
  });
};

// --------------------------------------------------------------------------
export var fixJSON = (filepath, func) => {
  var contents, hJson, output;
  contents = fs.readFileSync(filepath, {
    encoding: 'utf8'
  });
  hJson = JSON.parse(contents);
  func(hJson); // modify in place
  output = JSON.stringify(hJson, null, 3);
  output = fixOutput(output);
  fs.writeFileSync(filepath, output, {
    encoding: 'utf8'
  });
};

// ---------------------------------------------------------------------------
export var cloneRepo = (user, repo, dir) => {
  var git_repo;
  git_repo = `https://github.com/${user}/${repo}.git`;
  return runCmd(`git clone ${git_repo} ${dir}`);
};

// ---------------------------------------------------------------------------
export var homeDir = () => {
  return mkpath(os.homedir());
};

// ---------------------------------------------------------------------------
export var projRoot = (url) => {
  var dir, rootDir;
  dir = mydir(url);
  rootDir = pathTo('package.json', dir, 'direction=up directory');
  assert(defined(rootDir), "No project root directory found");
  return rootDir;
};

// ---------------------------------------------------------------------------
//    myfile() - pass argument import.meta.url and it will return
//               the name of your file
export var myfile = (url) => {
  var filename, path;
  path = urllib.fileURLToPath(url);
  filename = pathlib.parse(path).base;
  return filename;
};

// ---------------------------------------------------------------------------
//    myfullpath() - pass argument import.meta.url and it will return
//                   the full path to your file
export var myfullpath = (url) => {
  var path;
  path = urllib.fileURLToPath(url);
  return mkpath(path);
};

// ---------------------------------------------------------------------------
export var getStats = (fullpath) => {
  return fs.lstatSync(fullpath);
};

// ---------------------------------------------------------------------------
export var isSimpleFileName = (path) => {
  var h;
  h = pathlib.parse(path);
  return !h.root && !h.dir && h.base;
};

// ---------------------------------------------------------------------------
export var fileStub = (path) => {
  var lMatches;
  assert(isString(path), "fileStub(): path not a string");
  if (lMatches = path.match(/^(.*)\.[A-Za-z0-9_]+$/)) {
    return lMatches[1];
  } else {
    return '';
  }
};

// ---------------------------------------------------------------------------
export var getFullPath = (filepath) => {
  return mkpath(pathlib.resolve(filepath));
};

// ---------------------------------------------------------------------------
export var forEachBlock = (filepath, func, regexp = /^-{16,}$/) => {
  var callback, earlyExit, firstLineNum, lLines;
  lLines = [];
  firstLineNum = 1;
  earlyExit = false;
  callback = function(line, lineNum) {
    var result;
    if (line.match(regexp)) {
      if (result = func(lLines.join('\n'), firstLineNum, line)) {
        if (result === true) {
          earlyExit = true;
          return true;
        } else if (defined(result)) {
          croak(`forEachBlock() - callback returned '${result}'`);
        }
      }
      lLines = [];
      firstLineNum = lineNum + 1;
    } else {
      lLines.push(line);
    }
    return false;
  };
  forEachLineInFile(filepath, callback);
  if (!earlyExit) {
    func(lLines.join('\n'), firstLineNum);
  }
};

// ---------------------------------------------------------------------------
export var forEachSetOfBlocks = (filepath, func, block_regexp = /^-{16,}$/, set_regexp = /^={16,}$/) => {
  var callback, earlyExit, firstLineNum, lBlocks, lLines;
  dbgEnter('forEachSetOfBlocks', filepath);
  lBlocks = [];
  lLines = [];
  firstLineNum = 1;
  earlyExit = false;
  callback = function(line, hContext) {
    var lineNum, result;
    dbgEnter('callback', line, hContext.lineNum);
    lineNum = hContext.lineNum;
    if (line.match(set_regexp)) {
      lBlocks.push(lLines.join('\n'));
      lLines = [];
      result = func(deepCopy(lBlocks), firstLineNum, line);
      if (result === true) {
        earlyExit = true;
        dbgReturn('callback', true);
        return true;
      }
      lBlocks = [];
      firstLineNum = lineNum + 1;
    } else if (line.match(block_regexp)) {
      lBlocks.push(lLines.join('\n'));
      lLines = [];
    } else {
      lLines.push(line);
    }
    dbgReturn('callback', false);
    return false;
  };
  forEachLineInFile(filepath, callback);
  if (!earlyExit) {
    lBlocks.push(lLines.join('\n'));
    func(lBlocks, firstLineNum);
  }
  dbgReturn('forEachSetOfBlocks');
};

// ---------------------------------------------------------------------------
//   removeFileWithExt - remove file with different ext
export var removeFileWithExt = (path, newExt, hOptions = {}) => {
  var doLog, err, fullpath, success;
  // --- Valid options:
  //        doLog
  ({doLog} = getOptions(hOptions));
  fullpath = withExt(path, newExt);
  try {
    fs.unlinkSync(fullpath);
    if (doLog) {
      LOG(`   unlink ${filename}`);
    }
    success = true;
  } catch (error) {
    err = error;
    LOG(`   UNLINK FAILED: ${err.message}`);
    success = false;
  }
  return success;
};

// ---------------------------------------------------------------------------
isHiddenDir = function(dir) {
  var base, hFileInfo;
  hFileInfo = parsePath(dir);
  base = hFileInfo.lDirs.pop();
  return base.substring(0, 1) === '.';
};

// ---------------------------------------------------------------------------
isSystemDir = function(dir) {
  return dir === '$Recycle.Bin' || dir === '$WinREAgent';
};

// ---------------------------------------------------------------------------
//    Get all subdirectories of a directory
//       don't return hidden or system subdirectories
//    Return value is just named, not full paths
export var getSubDirs = (dir) => {
  var doInclude, hOptions, lSubDirs;
  dbgEnter('getSubDirs', dir);
  assert(isDir(dir), "not a directory");
  doInclude = function(d) {
    var dirName;
    if (!d.isDirectory()) {
      return false;
    }
    dirName = d.name;
    if (isSystemDir(dirName) || (dirName.substring(0, 1) === '.')) {
      return false;
    }
    return true;
  };
  hOptions = {
    withFileTypes: true,
    recursive: false
  };
  lSubDirs = fs.readdirSync(dir, hOptions).filter(doInclude).map(function(d) {
    return d.name;
  }).sort();
  dbgReturn('getSubDirs', lSubDirs);
  return lSubDirs;
};

// ---------------------------------------------------------------------------
//    Get path to parent directory of a directory
export var getParentDir = (dir) => {
  var hParts;
  hParts = pathlib.parse(dir);
  if (hParts.dir === hParts.root) {
    return undef;
  }
  return mkpath(pathlib.resolve(dir, '..'));
};

// ---------------------------------------------------------------------------
export var forEachFile = (dir, cb, filt = undef, level = 0) => {
  var ent, i, j, lSubDirectories, len, len1, ref, ref1, subdir;
  // --- filt can be a regular expression or a function that gets:
  //        (filename, dir, level)
  //     callback will get parms (filename, dir, level)
  lSubDirectories = [];
  ref = fs.readdirSync(dir, {
    withFileTypes: true
  });
  for (i = 0, len = ref.length; i < len; i++) {
    ent = ref[i];
    if (ent.isDirectory()) {
      lSubDirectories.push(ent);
    } else if (ent.isFile()) {
      if (notdefined(filt)) {
        cb(ent.name, dir, level);
      } else if (isRegExp(filt)) {
        if (ent.name.match(filt)) {
          cb(ent.name, dir, level);
        }
      } else if (isFunction(filt)) {
        if (filt(ent.name, dir, level)) {
          cb(ent.name, dir, level);
        }
      } else {
        croak("forEachFile(): bad filter", 'filter', filt);
      }
    }
  }
  if (nonEmpty(lSubDirectories)) {
    ref1 = lSubDirectories.sort();
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      subdir = ref1[j];
      forEachFile(mkpath(dir, subdir.name), cb, filt, level + 1);
    }
  }
};

// ---------------------------------------------------------------------------
export var pathTo = (fname, searchDir, hOptions = {}) => {
  var dirPath, direction, directory, filepath, fpath, i, lSubDirs, len, nLevels, relative, result, subdir;
  dbgEnter('pathTo', fname, searchDir, hOptions);
  ({direction, relative, directory} = getOptions(hOptions, {
    direction: 'down',
    relative: false,
    directory: false // return only the directory the file is in
  }));
  dbg(`direction = ${direction}`);
  dbg(`relative = ${relative}`);
  dbg(`directory = ${directory}`);
  assert(!(relative && directory), "relative & directory are incompatible");
  if (!searchDir) {
    searchDir = process.cwd();
  }
  assert(isDir(searchDir), `Not a directory: ${OL(searchDir)}`);
  // --- first check if the file is in searchDir
  filepath = mkpath(searchDir, fname);
  if (isFile(filepath)) {
    if (relative) {
      result = `./${fname}`;
    } else if (directory) {
      result = mkpath(searchDir);
    } else {
      result = mkpath(filepath);
    }
    dbgReturn('pathTo', result);
    return result;
  }
  dbg(`not found in searchDir '${searchDir}'`);
  if (direction === 'down') {
    // --- Search all directories in this directory
    //     getSubDirs() returns dirs sorted alphabetically
    lSubDirs = getSubDirs(searchDir);
    dbg('lSubDirs', lSubDirs);
    for (i = 0, len = lSubDirs.length; i < len; i++) {
      subdir = lSubDirs[i];
      // --- subdir is a simple name, not a full path
      dirPath = mkpath(searchDir, subdir);
      fpath = pathTo(fname, dirPath, hOptions);
      if (defined(fpath)) {
        if (relative) {
          result = fpath.replace('./', `./${subdir}/`);
        } else if (directory) {
          result = mkpath(dirPath);
        } else {
          result = mkpath(fpath);
        }
        dbgReturn('pathTo', result);
        return result;
      }
    }
  } else if (direction === 'up') {
    nLevels = 0;
    while (defined(dirPath = getParentDir(searchDir))) {
      nLevels += 1;
      fpath = mkpath(dirPath, fname);
      if (isFile(fpath)) {
        if (relative) {
          result = "../".repeat(nLevels) + fname;
        } else if (directory) {
          result = mkpath(dirPath);
        } else {
          result = mkpath(fpath);
        }
        dbgReturn('pathTo', result);
        return result;
      }
      searchDir = dirPath;
    }
  } else {
    croak(`pathTo(): Invalid direction '${direction}'`);
  }
  dbgReturn('pathTo', undef);
  return undef;
};

// ---------------------------------------------------------------------------
export var allPathsTo = (fname, searchDir) => {
  var h, lPaths, path;
  if (!searchDir) {
    searchDir = process.cwd();
  }
  path = pathTo(fname, searchDir, {
    direction: "up"
  });
  if (defined(path)) {
    lPaths = [path]; // --- build an array of paths
    // --- search upward for files, but return ordered top down
    while ((h = pathlib.parse(path)) && (path = pathTo(fname, pathlib.resolve(h.dir, '..'), {
        direction: "up"
      }))) {
      lPaths.unshift(path);
    }
    return lPaths;
  } else {
    return [];
  }
};

// ---------------------------------------------------------------------------
export var newerDestFileExists = (srcPath, destPath) => {
  var destModTime, srcModTime;
  if (!fs.existsSync(destPath)) {
    return false;
  }
  srcModTime = fs.statSync(srcPath).mtimeMs;
  destModTime = fs.statSync(destPath).mtimeMs;
  if (destModTime >= srcModTime) {
    return true;
  } else {
    return false;
  }
};

// ---------------------------------------------------------------------------
export var shortenPath = (path) => {
  var _, lMatches, str, tail;
  // --- Replace user's home dir with '~'
  str = mkpath(path);
  if (lMatches = str.match(/^[A-Za-z]:\/Users\/[a-z_][a-z0-9_]*\/(.*)$/i)) {
    [_, tail] = lMatches;
    return `~/${tail}`;
  } else {
    return str;
  }
};

// ---------------------------------------------------------------------------

//# sourceMappingURL=fs.js.map
