// Generated by CoffeeScript 2.7.0
  // KeyedSet.coffee
import {
  undef,
  defined,
  notdefined,
  OL,
  deepCopy,
  isString,
  isNonEmptyString,
  isArray,
  isHash,
  isEmpty,
  nonEmpty,
  isArrayOfStrings
} from '@jdeighan/base-utils';

import {
  assert,
  croak
} from '@jdeighan/base-utils/exceptions';

import {
  LOG,
  LOGVALUE
} from '@jdeighan/base-utils/log';

import {
  dbgEnter,
  dbgReturn,
  dbg
} from '@jdeighan/base-utils/debug';

// ---------------------------------------------------------------------------
export var KeyedSet = class KeyedSet extends Map {
  constructor(setName, lKeyNames, sep = '|') {
    var j, len, name;
    // --- lKeyNames can be:
    //        1. a non-empty string
    //        2. an array of non-empty strings
    dbgEnter('KeyedSet');
    super();
    this.setName = setName;
    this.sep = sep;
    assert(isNonEmptyString(this.setName), `bad set name: ${OL(this.setName)}`);
    if (isString(lKeyNames)) {
      assert(nonEmpty(lKeyNames), "empty string key name");
      this.lKeyNames = [lKeyNames];
      this.numKeys = 1;
    } else if (isArray(lKeyNames)) {
      assert(nonEmpty(lKeyNames), "empty key name array");
      for (j = 0, len = lKeyNames.length; j < len; j++) {
        name = lKeyNames[j];
        assert(isNonEmptyString(name), `name not a non-empty string: ${OL(name)}`);
      }
      this.numKeys = lKeyNames.length;
      this.lKeyNames = lKeyNames;
    } else {
      croak(`Invalid key names: ${OL(lKeyNames)}`);
    }
    dbg(`key is ${OL(this.lKeyNames)}`);
    dbgReturn('KeyedSet');
  }

  // ..........................................................
  add(keyVal, hData = {}) {
    var hItem, i, j, key, lKeyVals, len, name, ref;
    dbgEnter('add', keyVal, hData);
    assert(!this.has(keyVal), `adding duplicate key ${OL(keyVal)}`);
    assert(isHash(hData), `hData not a hash: ${OL(hData)}`);
    dbg("not a duplicate");
    hItem = deepCopy(hData);
    // --- Add key values to hItem
    lKeyVals = this.getKeyValues(keyVal);
    ref = this.lKeyNames;
    for (i = j = 0, len = ref.length; j < len; i = ++j) {
      name = ref[i];
      assert(notdefined(hItem[name]), `hData has key ${name}`);
      hItem[name] = lKeyVals[i];
    }
    key = this.getKey(keyVal);
    dbg('key', key);
    dbg('value', hItem);
    this.set(key, hItem); // set() is a method in Map, the base class
    this.length = this.size; // add to all methods that change size
    dbgReturn('add');
    return this; // allow chaining
  }

  
    // ..........................................................
  getKey(keyVal) {
    var key;
    // --- Get the actual key used in the underlying Map object
    dbgEnter('getKey');
    key = this.getKeyValues(keyVal).join(this.sep);
    dbgReturn('getKey', key);
    return key;
  }

  // ..........................................................
  getKeyValues(keyVal) {
    var j, lKeyVals, len, val;
    // --- Accepts either a string or an array of strings
    //     But all keys must be non-empty strings
    //     Always returns an array
    dbgEnter('getKeyValues', keyVal);
    if (isString(keyVal)) {
      lKeyVals = [keyVal];
    } else if (isArray(keyVal)) {
      lKeyVals = keyVal;
    } else {
      croak(`Bad key value: ${OL(keyVal)}`);
    }
    assert(lKeyVals.length === this.numKeys, `Bad # keys in ${OL(keyVal)}`);
    for (j = 0, len = lKeyVals.length; j < len; j++) {
      val = lKeyVals[j];
      assert(isNonEmptyString(val), `Bad key val: ${OL(val)}`);
    }
    dbgReturn('getKeyValues', lKeyVals);
    return lKeyVals;
  }

  // ..........................................................
  has(keyVal) {
    return super.has(this.getKey(keyVal));
  }

  // ..........................................................
  update(keyVal, hData = {}) {
    var hItem, key, val;
    dbgEnter('update', keyVal, hData);
    key = this.getKey(keyVal);
    dbg(`key = ${OL(key)}`);
    hItem = this.get(key);
    dbg('hItem', hItem);
    assert(defined(hItem), `updating missing key ${OL(keyVal)}`);
    for (key in hData) {
      val = hData[key];
      hItem[key] = val;
    }
    dbgReturn('update');
    return this; // allow chaining
  }

  
    // ..........................................................
  remove(keyVal) {
    var key;
    key = this.getKey(keyVal);
    if (!this.delete(key)) {
      croak(`No key ${OL(keyVal)} in ${this.setName}`);
    }
    this.length = this.size; // add to all methods that change size
    return this; // allow chaining
  }

  
    // ..........................................................
  getAllItems() {
    // --- Useful for unit tests, but it's usually better
    //     to use a generator like .entries()
    return Array.from(this.values());
  }

  // ..........................................................
  get(keyVal) {
    var item;
    // --- Override to require that it exists
    item = super.get(this.getKey(keyVal));
    assert(defined(item), `No such item: ${OL(keyVal)} in ${this.setName}`);
    return item;
  }

  // ..........................................................
  dump() {
    var key, ref, results, value, x;
    console.log(`DUMP ${this.setName}:`);
    ref = this.entries();
    results = [];
    for (x of ref) {
      [key, value] = x;
      results.push(console.log(`${OL(key)}: ${OL(value)}`));
    }
    return results;
  }

};

// ---------------------------------------------------------------------------

//# sourceMappingURL=KeyedSet.js.map
