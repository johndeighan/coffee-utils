// Generated by CoffeeScript 2.7.0
// log_utils.coffee
var doDebugLog, escReplacer, fixForTerminal, fourSpaces, loaded, maxOneLine, putBlock, putstr;

import yaml from 'js-yaml';

import {
  assert,
  error,
  croak
} from '@jdeighan/unit-tester/utils';

import {
  undef,
  isNumber,
  isInteger,
  isString,
  isHash,
  isFunction,
  escapeStr,
  sep_eq,
  sep_dash,
  pass,
  OL
} from '@jdeighan/coffee-utils';

import {
  blockToArray
} from '@jdeighan/coffee-utils/block';

import {
  tabify,
  untabify,
  indentation,
  indented
} from '@jdeighan/coffee-utils/indent';

// --- This logger only ever gets passed a single string argument
putstr = undef;

doDebugLog = false;

export var stringify = undef;

fourSpaces = '    ';

// ---------------------------------------------------------------------------
export var debugLog = function(flag = true) {
  doDebugLog = flag;
  if (doDebugLog) {
    LOG(`doDebugLog = ${flag}`);
  }
};

// ---------------------------------------------------------------------------
// This is useful for debugging
export var LOG = function(...lArgs) {
  var item, label;
  [label, item] = lArgs;
  if (lArgs.length > 1) {
    // --- There's both a label and an item
    if (item === undef) {
      console.log(`${label} = undef`);
    } else if (item === null) {
      console.log(`${label} = null`);
    } else {
      console.log(sep_dash);
      console.log(`${label}:`);
      if (isString(item)) {
        console.log(untabify(item));
      } else {
        console.log(untabify(orderedStringify(item)));
      }
      console.log(sep_dash);
    }
  } else {
    console.log(label);
  }
  return true; // to allow use in boolean expressions
};


// --- Use this instead to make it easier to remove all instances
export var DEBUG = LOG; // synonym


// ---------------------------------------------------------------------------
export var LOGLINES = function(label, lLines) {
  var i, len, line;
  LOG(`${label}:`);
  for (i = 0, len = lLines.length; i < len; i++) {
    line = lLines[i];
    LOG(`${OL(line)}`);
  }
};

// ---------------------------------------------------------------------------
export var setStringifier = function(func) {
  var orgStringifier;
  orgStringifier = stringify;
  assert(isFunction(func), "setStringifier() arg is not a function");
  stringify = func;
  return orgStringifier;
};

// ---------------------------------------------------------------------------
export var resetStringifier = function() {
  return setStringifier(orderedStringify);
};

// ---------------------------------------------------------------------------
export var setLogger = function(func) {
  var orgLogger;
  assert(isFunction(func), "setLogger() arg is not a function");
  orgLogger = putstr;
  putstr = func;
  return orgLogger;
};

// ---------------------------------------------------------------------------
export var resetLogger = function() {
  return setLogger(console.log);
};

// ---------------------------------------------------------------------------
escReplacer = function(name, value) {
  if (!isString(value)) {
    return value;
  }
  return escapeStr(value);
};

// ---------------------------------------------------------------------------
export var tamlStringify = function(obj, escape = false) {
  var str;
  str = yaml.dump(obj, {
    skipInvalid: true,
    indent: 1,
    sortKeys: false,
    lineWidth: -1,
    replacer: escape ? escReplacer : function(name, value) {
      return value;
    }
  });
  return "---\n" + str;
};

// ---------------------------------------------------------------------------
export var orderedStringify = function(obj, escape = false) {
  var str;
  str = yaml.dump(obj, {
    skipInvalid: true,
    indent: 1,
    sortKeys: true,
    lineWidth: 40,
    replacer: escape ? escReplacer : function(name, value) {
      return value;
    }
  });
  return "---\n" + str;
};

// ---------------------------------------------------------------------------
maxOneLine = 32;

// ---------------------------------------------------------------------------
export var log = function(str, prefix = '') {
  assert(isString(prefix), `not a string: ${OL(prefix)}`);
  assert(isString(str), `log(): not a string: ${OL(str)}`);
  assert(isFunction(putstr), "putstr not properly set");
  prefix = fixForTerminal(prefix);
  if (doDebugLog) {
    LOG(`CALL log(${OL(str)}), prefix = ${OL(prefix)}`);
  }
  putstr(`${prefix}${str}`);
  return true; // to allow use in boolean expressions
};


// ---------------------------------------------------------------------------
export var logBareItem = function(item, pre = '') {
  logItem(undef, item, pre);
};

// ---------------------------------------------------------------------------
export var logItem = function(label, item, pre = '', itemPre = undef) {
  var i, labelStr, len, ref, str;
  assert(isString(pre), `not a string: ${OL(pre)}`);
  assert(isFunction(putstr), "putstr not properly set");
  assert(!label || isString(label), "label a non-string");
  if (itemPre === undef) {
    itemPre = pre;
  }
  assert(pre.indexOf("\t") === -1, "pre has TAB");
  assert(itemPre.indexOf("\t") === -1, "itemPre has TAB");
  if (doDebugLog) {
    LOG(`CALL logItem(${OL(label)}, ${OL(item)})`);
    LOG(`pre = ${OL(pre)}`);
    LOG(`itemPre = ${OL(itemPre)}`);
  }
  labelStr = label ? `${label} = ` : "";
  if (item === undef) {
    putstr(`${pre}${labelStr}undef`);
  } else if (item === null) {
    putstr(`${pre}${labelStr}null`);
  } else if (isNumber(item)) {
    putstr(`${pre}${labelStr}${item}`);
  } else if (isString(item)) {
    if (item.length <= maxOneLine) {
      putstr(`${pre}${labelStr}'${escapeStr(item)}'`);
    } else {
      if (label) {
        putstr(`${pre}${label}:`);
      }
      putBlock(item, itemPre);
    }
  } else {
    if (label) {
      putstr(`${pre}${label}:`);
    }
    ref = blockToArray(stringify(item, true));
    // --- escape special chars
    for (i = 0, len = ref.length; i < len; i++) {
      str = ref[i];
      putstr(`${itemPre}${str}`);
    }
  }
  return true;
};

// ---------------------------------------------------------------------------
export var shortEnough = function(label, value) {
  return value === undef;
};

// ---------------------------------------------------------------------------
// --- needed because Windows Terminal handles TAB chars badly
fixForTerminal = function(str) {
  if (!str) {
    return '';
  }
  // --- convert TAB char to 4 spaces
  return str.replace(/\t/g, fourSpaces);
};

// ---------------------------------------------------------------------------
putBlock = function(item, prefix = '') {
  var i, len, line, ref;
  putstr(`${prefix}${sep_eq}`);
  ref = blockToArray(item);
  for (i = 0, len = ref.length; i < len; i++) {
    line = ref[i];
    putstr(`${prefix}${escapeStr(line)}`);
  }
  putstr(`${prefix}${sep_eq}`);
};

if (!loaded) {
  setStringifier(orderedStringify);
  resetLogger();
}

loaded = true;
