// Generated by CoffeeScript 2.6.1
// log_utils.coffee
var escReplacer, loaded, maxOneLine, objSep, putstr;

import yaml from 'js-yaml';

import {
  assert,
  undef,
  isNumber,
  isInteger,
  isString,
  isHash,
  isFunction,
  escapeStr,
  sep_eq,
  sep_dash
} from '@jdeighan/coffee-utils';

import {
  blockToArray
} from '@jdeighan/coffee-utils/block';

import {
  tabify,
  untabify,
  indentation
} from '@jdeighan/coffee-utils/indent';

import {
  arrow,
  hasArrow,
  removeArrow
} from '@jdeighan/coffee-utils/arrow';

// --- This logger only ever gets passed a single string argument
putstr = undef;

export var stringify = undef;

objSep = '-'.repeat(42);

// ---------------------------------------------------------------------------
// This is useful for debugging and easy to remove after debugging
export var LOG = function(...lArgs) {
  var item, label;
  [label, item] = lArgs;
  if (lArgs.length > 1) {
    console.log(objSep);
    if (item != null) {
      console.log(`${label}:`);
      console.log(untabify(orderedStringify(item)));
    } else {
      console.log(`[${label}]: UNDEFINED`);
    }
    console.log(objSep);
  } else {
    console.log(label);
  }
};

export var DEBUG = LOG; // synonym


// ---------------------------------------------------------------------------
export var setStringifier = function(func) {
  var orgStringifier;
  orgStringifier = stringify;
  assert(isFunction(func), "setStringifier() arg is not a function");
  stringify = func;
  return orgStringifier;
};

// ---------------------------------------------------------------------------
export var resetStringifier = function() {
  return setStringifier(orderedStringify);
};

// ---------------------------------------------------------------------------
export var setLogger = function(func) {
  var orgLogger;
  assert(isFunction(func), "setLogger() arg is not a function");
  orgLogger = putstr;
  putstr = func;
  return orgLogger;
};

// ---------------------------------------------------------------------------
export var resetLogger = function() {
  return setLogger(console.log);
};

// ---------------------------------------------------------------------------
escReplacer = function(name, value) {
  if (!isString(value)) {
    return value;
  }
  return escapeStr(value);
};

// ---------------------------------------------------------------------------
export var tamlStringify = function(obj, escape = false) {
  var str;
  str = yaml.dump(obj, {
    skipInvalid: true,
    indent: 1,
    sortKeys: false,
    lineWidth: -1,
    replacer: escape ? escReplacer : function(name, value) {
      return value;
    }
  });
  return "---\n" + tabify(str, 1);
};

// ---------------------------------------------------------------------------
export var orderedStringify = function(obj, escape = false) {
  var str;
  str = yaml.dump(obj, {
    skipInvalid: true,
    indent: 1,
    sortKeys: true,
    lineWidth: -1,
    replacer: escape ? escReplacer : function(name, value) {
      return value;
    }
  });
  return "---\n" + tabify(str, 1);
};

// ---------------------------------------------------------------------------
maxOneLine = 32;

// ---------------------------------------------------------------------------
export var log = function(item, hOptions = {}) {
  var i, itemPrefix, j, label, len, len1, line, prefix, ref, ref1, str;
  // --- valid options:
  //   label
  //   prefix
  //   itemPrefix
  //   escape
  assert(isFunction(putstr), "putstr not properly set");
  if (isString(hOptions)) {
    label = hOptions;
    prefix = itemPrefix = '';
  } else {
    assert(isHash(hOptions), "log(): 2nd arg must be a string or hash");
    label = hOptions.label || '';
    prefix = hOptions.prefix || '';
    itemPrefix = hOptions.itemPrefix || prefix || '';
  }
  // --- If putstr is console.log, we'll convert TAB char to 3 spaces
  if (putstr === console.log) {
    label = untabify(label);
    prefix = untabify(prefix);
    itemPrefix = untabify(itemPrefix);
  }
  if (isString(item) && (label === '')) {
    if (hOptions.escape) {
      putstr(`${prefix}${escapeStr(item)}`);
    } else {
      putstr(`${prefix}${item}`);
    }
    return;
  }
  if (label === '') {
    label = 'ITEM';
  }
  if (item === undef) {
    putstr(`${prefix}${label} = undef`);
  } else if (isString(item)) {
    if (item.length <= maxOneLine) {
      putstr(`${prefix}${label} = '${escapeStr(item)}'`);
    } else {
      putstr(`${prefix}${label}:`);
      putstr(`${itemPrefix}${sep_eq}`);
      ref = blockToArray(item);
      for (i = 0, len = ref.length; i < len; i++) {
        line = ref[i];
        putstr(`${itemPrefix}${escapeStr(line)}`);
      }
      putstr(`${itemPrefix}${sep_eq}`);
    }
  } else if (isNumber(item)) {
    putstr(`${prefix}${label} = ${item}`);
  } else {
    putstr(`${removeArrow(prefix, true)}${objSep}`);
    putstr(`${prefix}${label}:`);
    ref1 = blockToArray(stringify(item, true));
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      str = ref1[j];
      if (putstr === console.log) {
        putstr(`${itemPrefix}   ${untabify(str)}`);
      } else {
        putstr(`${itemPrefix}${indentation(1)}${str}`);
      }
    }
    putstr(`${removeArrow(prefix, false)}${objSep}`);
  }
};

if (!loaded) {
  setStringifier(orderedStringify);
  resetLogger();
}

loaded = true;
