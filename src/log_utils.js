// Generated by CoffeeScript 2.6.1
// log_utils.coffee
var escReplacer, loaded, logger, maxOneLine;

import yaml from 'js-yaml';

import {
  assert,
  undef,
  isNumber,
  isInteger,
  isString,
  isHash,
  isFunction,
  escapeStr,
  sep_eq
} from '@jdeighan/coffee-utils';

import {
  blockToArray
} from '@jdeighan/coffee-utils/block';

import {
  tabify,
  untabify
} from '@jdeighan/coffee-utils/indent';

// --- This logger only ever gets passed a single string argument
logger = undef;

export var stringify = undef;

export var id = 42;

// ---------------------------------------------------------------------------
export var setStringifier = function(func) {
  var orgStringifier;
  orgStringifier = stringify;
  assert(isFunction(func), "setStringifier() arg is not a function");
  stringify = func;
  return orgStringifier;
};

// ---------------------------------------------------------------------------
export var resetStringifier = function() {
  return setStringifier(orderedStringify);
};

// ---------------------------------------------------------------------------
export var setLogger = function(func) {
  var orgLogger;
  orgLogger = logger;
  assert(isFunction(func), "setLogger() arg is not a function");
  logger = func;
  return orgLogger;
};

// ---------------------------------------------------------------------------
export var resetLogger = function() {
  return setLogger(console.log);
};

// ---------------------------------------------------------------------------
escReplacer = function(name, value) {
  if (!isString(value)) {
    return value;
  }
  return escapeStr(value);
};

// ---------------------------------------------------------------------------
export var tamlStringify = function(obj, escape = false) {
  var str;
  str = yaml.dump(obj, {
    skipInvalid: true,
    indent: 1,
    sortKeys: false,
    lineWidth: -1,
    replacer: escape ? escReplacer : function(name, value) {
      return value;
    }
  });
  return "---\n" + tabify(str, 1);
};

// ---------------------------------------------------------------------------
export var orderedStringify = function(obj, escape = false) {
  var str;
  str = yaml.dump(obj, {
    skipInvalid: true,
    indent: 1,
    sortKeys: true,
    lineWidth: -1,
    replacer: escape ? escReplacer : function(name, value) {
      return value;
    }
  });
  return "---\n" + tabify(str, 1);
};

// ---------------------------------------------------------------------------
maxOneLine = 32;

// ---------------------------------------------------------------------------
export var log = function(item, hOptions = undef) {
  var i, itemPrefix, j, label, len, len1, line, prefix, ref, ref1, str;
  // --- valid options:
  //        label
  //        prefix
  //        escape
  assert(isFunction(logger), "logger not properly set");
  prefix = itemPrefix = label = '';
  if (hOptions != null) {
    if (isString(hOptions)) {
      label = hOptions;
    } else {
      assert(isHash(hOptions), "log(): 2nd arg must be a string or hash");
      if (hOptions.prefix != null) {
        prefix = hOptions.prefix;
      }
      if (hOptions.itemPrefix != null) {
        itemPrefix = hOptions.itemPrefix;
      } else {
        itemPrefix = prefix;
      }
      if (hOptions.label != null) {
        label = hOptions.label;
      }
    }
  }
  if (isString(item) && (label === '')) {
    if ((hOptions != null) && hOptions.escape) {
      logger(`${prefix}${escapeStr(item)}`);
    } else {
      logger(`${prefix}${item}`);
    }
    return;
  }
  if (label === '') {
    label = 'ITEM';
  }
  if (item === undef) {
    logger(`${prefix}${label} = undef`);
  } else if (isString(item)) {
    if (item.length <= maxOneLine) {
      logger(`${prefix}${label} = '${escapeStr(item)}'`);
    } else {
      logger(`${prefix}${label}:`);
      logger(`${itemPrefix}${sep_eq}`);
      ref = blockToArray(item);
      for (i = 0, len = ref.length; i < len; i++) {
        line = ref[i];
        logger(`${itemPrefix}${escapeStr(line)}`);
      }
      logger(`${itemPrefix}${sep_eq}`);
    }
  } else if (isNumber(item)) {
    logger(`${prefix}${label} = ${item}`);
  } else {
    logger(`${prefix}${label}:`);
    ref1 = blockToArray(stringify(item, true));
    for (j = 0, len1 = ref1.length; j < len1; j++) {
      str = ref1[j];
      logger(`${itemPrefix}\t${str}`);
    }
  }
};

if (!loaded) {
  setStringifier(orderedStringify);
  resetLogger();
}

loaded = true;
